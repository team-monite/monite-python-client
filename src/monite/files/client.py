# This file was auto-generated by Fern from our API Definition.

import typing

from .. import core
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from ..types.allowed_file_types import AllowedFileTypes
from ..types.file_response import FileResponse
from ..types.files_response import FilesResponse
from .raw_client import AsyncRawFilesClient, RawFilesClient

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class FilesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawFilesClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawFilesClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawFilesClient
        """
        return self._raw_client

    def get(
        self,
        *,
        id_in: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        file_type: typing.Optional[AllowedFileTypes] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FilesResponse:
        """
        The `/files` endpoint provides access to an entity's files hosted on Monite's servers. This includes both files uploaded by the entity and files that were automatically created by Monite (such as PDF versions of invoices).

        `GET /files` requires at least one query parameter, either `id__in` or `file_type`. You can use this operation to:

         * Bulk fetch multiple files by IDs.
         * Get all files with the given purpose (for example, invoice attachments).

        If no files matching the query parameters were found, the response contains an empty `data` array.

        Both partner tokens and entity user tokens can be used for authentication.

        Parameters
        ----------
        id_in : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only files with specified IDs. Valid but nonexistent IDs do not raise errors but produce no results.

            To specify multiple IDs, repeat this parameter for each value: `id__in=<id1>&id__in=<id2>`

        file_type : typing.Optional[AllowedFileTypes]
            Return only files with the given purpose. Possible values:

             * `additional_identity_documents` and `identity_documents` - [entity verification documents](https://docs.monite.com/payments/onboarding/via-api/documents) uploaded for payments onboarding.
             * `attachments` - supplementary attachments for accounts receivable invoices, quotes, and credit notes.
             * `delivery_notes` - auto-generated PDF versions of delivery notes.
             * `einvoices_xml` - e-invoice XML generated when sending e-invoices.
             * `payables` - payables (bills) received via email or uploaded via API.
             * `receivable_signatures` - images of customer signatures provided during quote acceptance.
             * `receivables` - auto-generated PDF versions of invoices, quotes, and credit notes.
             * `zip` - data export archives created by `POST /data_exports`.

            Other values are unused.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        FilesResponse
            Successful Response

        Examples
        --------
        from monite import Monite

        client = Monite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )
        client.files.get()
        """
        _response = self._raw_client.get(id_in=id_in, file_type=file_type, request_options=request_options)
        return _response.data

    def upload(
        self, *, file: core.File, file_type: AllowedFileTypes, request_options: typing.Optional[RequestOptions] = None
    ) -> FileResponse:
        """
        Upload files for use as:

         * supplementary attachments for invoices, quotes, and credit notes,
         * [entity verification documents](https://docs.monite.com/payments/onboarding/via-api/documents) for payments onboarding.

        Maximum file size is 15 MB. Each uploaded file is assigned a unique `id` that you can use to reference this file elsewhere.

        Both partner tokens and entity user tokens can be used for authentication.

        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        file_type : AllowedFileTypes
            The intended purpose of the file. Possible values:

             * `attachments` - supplemental attachments for accounts receivable invoices, quotes, and credit notes.
             * `identity_documents` - company registration documents or a person's identity documents for payments onboarding.
             * `additional_identity_documents` - documents that verify a person's address.

            Other enum values are not supposed to be used directly.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        FileResponse
            Successful Response

        Examples
        --------
        from monite import Monite

        client = Monite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )
        client.files.upload(
            file_type="ocr_results",
        )
        """
        _response = self._raw_client.upload(file=file, file_type=file_type, request_options=request_options)
        return _response.data

    def get_by_id(self, file_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> FileResponse:
        """
        Returns the details of an existing file. To bulk fetch multiple files by their IDs, use `GET /files?id__in=<ID1>&id__in=<ID2>`.

        Both partner tokens and entity user tokens can be used for authentication.

        Parameters
        ----------
        file_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        FileResponse
            Successful Response

        Examples
        --------
        from monite import Monite

        client = Monite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )
        client.files.get_by_id(
            file_id="file_id",
        )
        """
        _response = self._raw_client.get_by_id(file_id, request_options=request_options)
        return _response.data

    def delete(self, file_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Delete a file with the specified ID.

        **Note:** This endpoint does not check if the specified file is in use. Use with caution.

        Both partner tokens and entity user tokens can be used for authentication.
        #### Considerations for invoice attachments
        Deleting a file does not delete it from the `attachments` list of accounts receivable invoices, quotes, and credit notes because these documents contain an inline copy of all referenced resources. To delete a file from attachments, call `PATCH /receivables/{receivable_id}` and update the `attachments` list to exclude the deleted file.

        Parameters
        ----------
        file_id : str
            ID of the file you want to delete.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from monite import Monite

        client = Monite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )
        client.files.delete(
            file_id="file_id",
        )
        """
        _response = self._raw_client.delete(file_id, request_options=request_options)
        return _response.data


class AsyncFilesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawFilesClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawFilesClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawFilesClient
        """
        return self._raw_client

    async def get(
        self,
        *,
        id_in: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        file_type: typing.Optional[AllowedFileTypes] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FilesResponse:
        """
        The `/files` endpoint provides access to an entity's files hosted on Monite's servers. This includes both files uploaded by the entity and files that were automatically created by Monite (such as PDF versions of invoices).

        `GET /files` requires at least one query parameter, either `id__in` or `file_type`. You can use this operation to:

         * Bulk fetch multiple files by IDs.
         * Get all files with the given purpose (for example, invoice attachments).

        If no files matching the query parameters were found, the response contains an empty `data` array.

        Both partner tokens and entity user tokens can be used for authentication.

        Parameters
        ----------
        id_in : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only files with specified IDs. Valid but nonexistent IDs do not raise errors but produce no results.

            To specify multiple IDs, repeat this parameter for each value: `id__in=<id1>&id__in=<id2>`

        file_type : typing.Optional[AllowedFileTypes]
            Return only files with the given purpose. Possible values:

             * `additional_identity_documents` and `identity_documents` - [entity verification documents](https://docs.monite.com/payments/onboarding/via-api/documents) uploaded for payments onboarding.
             * `attachments` - supplementary attachments for accounts receivable invoices, quotes, and credit notes.
             * `delivery_notes` - auto-generated PDF versions of delivery notes.
             * `einvoices_xml` - e-invoice XML generated when sending e-invoices.
             * `payables` - payables (bills) received via email or uploaded via API.
             * `receivable_signatures` - images of customer signatures provided during quote acceptance.
             * `receivables` - auto-generated PDF versions of invoices, quotes, and credit notes.
             * `zip` - data export archives created by `POST /data_exports`.

            Other values are unused.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        FilesResponse
            Successful Response

        Examples
        --------
        import asyncio

        from monite import AsyncMonite

        client = AsyncMonite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.files.get()


        asyncio.run(main())
        """
        _response = await self._raw_client.get(id_in=id_in, file_type=file_type, request_options=request_options)
        return _response.data

    async def upload(
        self, *, file: core.File, file_type: AllowedFileTypes, request_options: typing.Optional[RequestOptions] = None
    ) -> FileResponse:
        """
        Upload files for use as:

         * supplementary attachments for invoices, quotes, and credit notes,
         * [entity verification documents](https://docs.monite.com/payments/onboarding/via-api/documents) for payments onboarding.

        Maximum file size is 15 MB. Each uploaded file is assigned a unique `id` that you can use to reference this file elsewhere.

        Both partner tokens and entity user tokens can be used for authentication.

        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        file_type : AllowedFileTypes
            The intended purpose of the file. Possible values:

             * `attachments` - supplemental attachments for accounts receivable invoices, quotes, and credit notes.
             * `identity_documents` - company registration documents or a person's identity documents for payments onboarding.
             * `additional_identity_documents` - documents that verify a person's address.

            Other enum values are not supposed to be used directly.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        FileResponse
            Successful Response

        Examples
        --------
        import asyncio

        from monite import AsyncMonite

        client = AsyncMonite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.files.upload(
                file_type="ocr_results",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.upload(file=file, file_type=file_type, request_options=request_options)
        return _response.data

    async def get_by_id(self, file_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> FileResponse:
        """
        Returns the details of an existing file. To bulk fetch multiple files by their IDs, use `GET /files?id__in=<ID1>&id__in=<ID2>`.

        Both partner tokens and entity user tokens can be used for authentication.

        Parameters
        ----------
        file_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        FileResponse
            Successful Response

        Examples
        --------
        import asyncio

        from monite import AsyncMonite

        client = AsyncMonite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.files.get_by_id(
                file_id="file_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get_by_id(file_id, request_options=request_options)
        return _response.data

    async def delete(self, file_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Delete a file with the specified ID.

        **Note:** This endpoint does not check if the specified file is in use. Use with caution.

        Both partner tokens and entity user tokens can be used for authentication.
        #### Considerations for invoice attachments
        Deleting a file does not delete it from the `attachments` list of accounts receivable invoices, quotes, and credit notes because these documents contain an inline copy of all referenced resources. To delete a file from attachments, call `PATCH /receivables/{receivable_id}` and update the `attachments` list to exclude the deleted file.

        Parameters
        ----------
        file_id : str
            ID of the file you want to delete.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from monite import AsyncMonite

        client = AsyncMonite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.files.delete(
                file_id="file_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.delete(file_id, request_options=request_options)
        return _response.data
