# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from .. import core
from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..errors.not_found_error import NotFoundError
from ..errors.too_many_requests_error import TooManyRequestsError
from ..errors.unauthorized_error import UnauthorizedError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.allowed_file_types import AllowedFileTypes
from ..types.file_response import FileResponse
from ..types.files_response import FilesResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawFilesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get(
        self,
        *,
        id_in: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        file_type: typing.Optional[AllowedFileTypes] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[FilesResponse]:
        """
        The `/files` endpoint provides access to an entity's files hosted on Monite's servers. This includes both files uploaded by the entity and files that were automatically created by Monite (such as PDF versions of invoices).

        `GET /files` requires at least one query parameter, either `id__in` or `file_type`. You can use this operation to:

         * Bulk fetch multiple files by IDs.
         * Get all files with the given purpose (for example, invoice attachments).

        If no files matching the query parameters were found, the response contains an empty `data` array.

        Both partner tokens and entity user tokens can be used for authentication.

        Parameters
        ----------
        id_in : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only files with specified IDs. Valid but nonexistent IDs do not raise errors but produce no results.

            To specify multiple IDs, repeat this parameter for each value: `id__in=<id1>&id__in=<id2>`

        file_type : typing.Optional[AllowedFileTypes]
            Return only files with the given purpose. Possible values:

             * `additional_identity_documents` and `identity_documents` - [entity verification documents](https://docs.monite.com/payments/onboarding/via-api/documents) uploaded for payments onboarding.
             * `attachments` - supplementary attachments for accounts receivable invoices, quotes, and credit notes.
             * `delivery_notes` - auto-generated PDF versions of delivery notes.
             * `einvoices_xml` - e-invoice XML generated when sending e-invoices.
             * `payables` - payables (bills) received via email or uploaded via API.
             * `receivable_signatures` - images of customer signatures provided during quote acceptance.
             * `receivables` - auto-generated PDF versions of invoices, quotes, and credit notes.
             * `zip` - data export archives created by `POST /data_exports`.

            Other values are unused.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[FilesResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "files",
            method="GET",
            params={
                "id__in": id_in,
                "file_type": file_type,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FilesResponse,
                    parse_obj_as(
                        type_=FilesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def upload(
        self, *, file: core.File, file_type: AllowedFileTypes, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[FileResponse]:
        """
        Upload files for use as:

         * supplementary attachments for invoices, quotes, and credit notes,
         * [entity verification documents](https://docs.monite.com/payments/onboarding/via-api/documents) for payments onboarding.

        Maximum file size is 15 MB. Each uploaded file is assigned a unique `id` that you can use to reference this file elsewhere.

        Both partner tokens and entity user tokens can be used for authentication.

        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        file_type : AllowedFileTypes
            The intended purpose of the file. Possible values:

             * `attachments` - supplemental attachments for accounts receivable invoices, quotes, and credit notes.
             * `identity_documents` - company registration documents or a person's identity documents for payments onboarding.
             * `additional_identity_documents` - documents that verify a person's address.

            Other enum values are not supposed to be used directly.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[FileResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "files",
            method="POST",
            data={
                "file_type": file_type,
            },
            files={
                "file": file,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FileResponse,
                    parse_obj_as(
                        type_=FileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_by_id(
        self, file_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[FileResponse]:
        """
        Returns the details of an existing file. To bulk fetch multiple files by their IDs, use `GET /files?id__in=<ID1>&id__in=<ID2>`.

        Both partner tokens and entity user tokens can be used for authentication.

        Parameters
        ----------
        file_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[FileResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"files/{jsonable_encoder(file_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FileResponse,
                    parse_obj_as(
                        type_=FileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete(self, file_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> HttpResponse[None]:
        """
        Delete a file with the specified ID.

        **Note:** This endpoint does not check if the specified file is in use. Use with caution.

        Both partner tokens and entity user tokens can be used for authentication.
        #### Considerations for invoice attachments
        Deleting a file does not delete it from the `attachments` list of accounts receivable invoices, quotes, and credit notes because these documents contain an inline copy of all referenced resources. To delete a file from attachments, call `PATCH /receivables/{receivable_id}` and update the `attachments` list to exclude the deleted file.

        Parameters
        ----------
        file_id : str
            ID of the file you want to delete.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"files/{jsonable_encoder(file_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawFilesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get(
        self,
        *,
        id_in: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        file_type: typing.Optional[AllowedFileTypes] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[FilesResponse]:
        """
        The `/files` endpoint provides access to an entity's files hosted on Monite's servers. This includes both files uploaded by the entity and files that were automatically created by Monite (such as PDF versions of invoices).

        `GET /files` requires at least one query parameter, either `id__in` or `file_type`. You can use this operation to:

         * Bulk fetch multiple files by IDs.
         * Get all files with the given purpose (for example, invoice attachments).

        If no files matching the query parameters were found, the response contains an empty `data` array.

        Both partner tokens and entity user tokens can be used for authentication.

        Parameters
        ----------
        id_in : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only files with specified IDs. Valid but nonexistent IDs do not raise errors but produce no results.

            To specify multiple IDs, repeat this parameter for each value: `id__in=<id1>&id__in=<id2>`

        file_type : typing.Optional[AllowedFileTypes]
            Return only files with the given purpose. Possible values:

             * `additional_identity_documents` and `identity_documents` - [entity verification documents](https://docs.monite.com/payments/onboarding/via-api/documents) uploaded for payments onboarding.
             * `attachments` - supplementary attachments for accounts receivable invoices, quotes, and credit notes.
             * `delivery_notes` - auto-generated PDF versions of delivery notes.
             * `einvoices_xml` - e-invoice XML generated when sending e-invoices.
             * `payables` - payables (bills) received via email or uploaded via API.
             * `receivable_signatures` - images of customer signatures provided during quote acceptance.
             * `receivables` - auto-generated PDF versions of invoices, quotes, and credit notes.
             * `zip` - data export archives created by `POST /data_exports`.

            Other values are unused.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[FilesResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "files",
            method="GET",
            params={
                "id__in": id_in,
                "file_type": file_type,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FilesResponse,
                    parse_obj_as(
                        type_=FilesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def upload(
        self, *, file: core.File, file_type: AllowedFileTypes, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[FileResponse]:
        """
        Upload files for use as:

         * supplementary attachments for invoices, quotes, and credit notes,
         * [entity verification documents](https://docs.monite.com/payments/onboarding/via-api/documents) for payments onboarding.

        Maximum file size is 15 MB. Each uploaded file is assigned a unique `id` that you can use to reference this file elsewhere.

        Both partner tokens and entity user tokens can be used for authentication.

        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        file_type : AllowedFileTypes
            The intended purpose of the file. Possible values:

             * `attachments` - supplemental attachments for accounts receivable invoices, quotes, and credit notes.
             * `identity_documents` - company registration documents or a person's identity documents for payments onboarding.
             * `additional_identity_documents` - documents that verify a person's address.

            Other enum values are not supposed to be used directly.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[FileResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "files",
            method="POST",
            data={
                "file_type": file_type,
            },
            files={
                "file": file,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FileResponse,
                    parse_obj_as(
                        type_=FileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_by_id(
        self, file_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[FileResponse]:
        """
        Returns the details of an existing file. To bulk fetch multiple files by their IDs, use `GET /files?id__in=<ID1>&id__in=<ID2>`.

        Both partner tokens and entity user tokens can be used for authentication.

        Parameters
        ----------
        file_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[FileResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"files/{jsonable_encoder(file_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FileResponse,
                    parse_obj_as(
                        type_=FileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete(
        self, file_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Delete a file with the specified ID.

        **Note:** This endpoint does not check if the specified file is in use. Use with caution.

        Both partner tokens and entity user tokens can be used for authentication.
        #### Considerations for invoice attachments
        Deleting a file does not delete it from the `attachments` list of accounts receivable invoices, quotes, and credit notes because these documents contain an inline copy of all referenced resources. To delete a file from attachments, call `PATCH /receivables/{receivable_id}` and update the `attachments` list to exclude the deleted file.

        Parameters
        ----------
        file_id : str
            ID of the file you want to delete.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"files/{jsonable_encoder(file_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
