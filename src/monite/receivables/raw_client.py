# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.datetime_utils import serialize_datetime
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.bad_request_error import BadRequestError
from ..errors.conflict_error import ConflictError
from ..errors.forbidden_error import ForbiddenError
from ..errors.not_acceptable_error import NotAcceptableError
from ..errors.not_found_error import NotFoundError
from ..errors.too_many_requests_error import TooManyRequestsError
from ..errors.unauthorized_error import UnauthorizedError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.allowed_countries import AllowedCountries
from ..types.counterpart_type import CounterpartType
from ..types.language_code_enum import LanguageCodeEnum
from ..types.line_item import LineItem
from ..types.line_items_response import LineItemsResponse
from ..types.order_enum import OrderEnum
from ..types.receivable_cursor_fields import ReceivableCursorFields
from ..types.receivable_cursor_fields2 import ReceivableCursorFields2
from ..types.receivable_facade_create_payload import ReceivableFacadeCreatePayload
from ..types.receivable_file_url import ReceivableFileUrl
from ..types.receivable_history_cursor_fields import ReceivableHistoryCursorFields
from ..types.receivable_history_event_type_enum import ReceivableHistoryEventTypeEnum
from ..types.receivable_history_pagination_response import ReceivableHistoryPaginationResponse
from ..types.receivable_history_response import ReceivableHistoryResponse
from ..types.receivable_mail_cursor_fields import ReceivableMailCursorFields
from ..types.receivable_mail_pagination_response import ReceivableMailPaginationResponse
from ..types.receivable_mail_response import ReceivableMailResponse
from ..types.receivable_mail_status_enum import ReceivableMailStatusEnum
from ..types.receivable_pagination_response import ReceivablePaginationResponse
from ..types.receivable_preview_response import ReceivablePreviewResponse
from ..types.receivable_required_fields import ReceivableRequiredFields
from ..types.receivable_response import ReceivableResponse
from ..types.receivable_send_response import ReceivableSendResponse
from ..types.receivable_templates_variables_object_list import ReceivableTemplatesVariablesObjectList
from ..types.receivable_type import ReceivableType
from ..types.receivable_update_payload import ReceivableUpdatePayload
from ..types.receivables_preview_type_enum import ReceivablesPreviewTypeEnum
from ..types.receivables_send_response import ReceivablesSendResponse
from ..types.receivables_verify_response import ReceivablesVerifyResponse
from ..types.recipients import Recipients
from ..types.reminder_type_enum import ReminderTypeEnum
from ..types.signature import Signature
from ..types.success_result import SuccessResult
from .types.receivables_get_request_status import ReceivablesGetRequestStatus
from .types.receivables_get_request_status_in_item import ReceivablesGetRequestStatusInItem
from .types.receivables_search_request_status import ReceivablesSearchRequestStatus

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawReceivablesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get(
        self,
        *,
        order: typing.Optional[OrderEnum] = None,
        limit: typing.Optional[int] = None,
        pagination_token: typing.Optional[str] = None,
        id_in: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        status_in: typing.Optional[
            typing.Union[ReceivablesGetRequestStatusInItem, typing.Sequence[ReceivablesGetRequestStatusInItem]]
        ] = None,
        entity_user_id_in: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        sort: typing.Optional[ReceivableCursorFields] = None,
        tag_ids_in: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        tag_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        product_ids_in: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        product_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        project_id_in: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        type: typing.Optional[ReceivableType] = None,
        document_id: typing.Optional[str] = None,
        document_id_contains: typing.Optional[str] = None,
        document_id_icontains: typing.Optional[str] = None,
        issue_date_gt: typing.Optional[dt.datetime] = None,
        issue_date_lt: typing.Optional[dt.datetime] = None,
        issue_date_gte: typing.Optional[dt.datetime] = None,
        issue_date_lte: typing.Optional[dt.datetime] = None,
        created_at_gt: typing.Optional[dt.datetime] = None,
        created_at_lt: typing.Optional[dt.datetime] = None,
        created_at_gte: typing.Optional[dt.datetime] = None,
        created_at_lte: typing.Optional[dt.datetime] = None,
        counterpart_id: typing.Optional[str] = None,
        counterpart_name: typing.Optional[str] = None,
        counterpart_name_contains: typing.Optional[str] = None,
        counterpart_name_icontains: typing.Optional[str] = None,
        total_amount: typing.Optional[int] = None,
        total_amount_gt: typing.Optional[int] = None,
        total_amount_lt: typing.Optional[int] = None,
        total_amount_gte: typing.Optional[int] = None,
        total_amount_lte: typing.Optional[int] = None,
        discounted_subtotal: typing.Optional[int] = None,
        discounted_subtotal_gt: typing.Optional[int] = None,
        discounted_subtotal_lt: typing.Optional[int] = None,
        discounted_subtotal_gte: typing.Optional[int] = None,
        discounted_subtotal_lte: typing.Optional[int] = None,
        status: typing.Optional[ReceivablesGetRequestStatus] = None,
        entity_user_id: typing.Optional[str] = None,
        based_on: typing.Optional[str] = None,
        due_date_gt: typing.Optional[str] = None,
        due_date_lt: typing.Optional[str] = None,
        due_date_gte: typing.Optional[str] = None,
        due_date_lte: typing.Optional[str] = None,
        project_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ReceivablePaginationResponse]:
        """
        Returns a list of [accounts receivable](https://docs.monite.com/accounts-receivable/index) documents - invoices, quotes, and credit notes - of the specified entity.

        Results can be filtered by amount, counterpart, due date, and other criteria. Multiple filters are combined using logical AND unless specified otherwise. If no documents matching the search criteria are found, the endpoint returns a successful response with an empty `data` array.

        This endpoint supports [pagination](https://docs.monite.com/api/concepts/pagination-sorting-filtering) and sorting. By default, results are sorted by the creation date in ascending order (from oldest to newest).

        #### Examples

        ##### Invoices

        * Get all overdue invoices:
            ```
            GET /receivables?type=invoice&status=overdue
            ```

        * Get all invoices created for the counterpart named "Solarwind" (case-insensitive):

            ```
            GET /receivables?type=invoice?counterpart_name__icontains=Solarwind
            ```

        * Get invoices whose total amount starts from 500 EUR:

            ```
            GET /receivables?type=invoice&total_amount__gte=50000
            ```

        * Get invoices that are due for payment in September 2024:

            ```
            GET /receivables?type=invoice&due_date__gte=2024-09-01T00:00:00Z&due_date__lt=2024-10-01T00:00:00Z
            ```

        * Get invoices created on or after September 1, 2024:

            ```
            GET /receivables?type=invoice&created_at__gte=2024-09-01T00:00:00Z
            ```

        * Find an invoice created from a specific quote:

            ```
            GET /receivables?type=invoice?based_on=QUOTE_ID
            ```

        ##### Quotes

        * Get the latest created quote:

            ```
            GET /receivables?type=quote&sort=created_at&order=desc&limit=1
            ```

        * Get the latest issued quote:

            ```
            GET /receivables?type=quote&sort=issue_date&order=desc&limit=1
            ```

        ##### Credit notes

        * Find all credit notes created for a specific invoice:

            ```
            GET /receivables?type=credit_note?based_on=INVOICE_ID
            ```

        Parameters
        ----------
        order : typing.Optional[OrderEnum]
            Sort order (ascending by default). Typically used together with the `sort` parameter.

        limit : typing.Optional[int]
            The number of items (0 .. 250) to return in a single page of the response. Default is 100. The response may contain fewer items if it is the last or only page.

            When using pagination with a non-default `limit`, you must provide the `limit` value alongside `pagination_token` in all subsequent pagination requests. Unlike other query parameters, `limit` is not inferred from `pagination_token`.

        pagination_token : typing.Optional[str]
            A pagination token obtained from a previous call to this endpoint. Use it to get the next or previous page of results for your initial query. If `pagination_token` is specified, all other query parameters except `limit` are ignored and inferred from the initial query.

            If not specified, the first page of results will be returned.

        id_in : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only receivables with the specified IDs. Valid but nonexistent IDs do not raise errors but produce no results.

            To specify multiple IDs, repeat this parameter for each value:
            `id__in=<id1>&id__in=<id2>`

        status_in : typing.Optional[typing.Union[ReceivablesGetRequestStatusInItem, typing.Sequence[ReceivablesGetRequestStatusInItem]]]
            Return only receivables that have the specified statuses. See the applicable [invoice statuses](https://docs.monite.com/accounts-receivable/invoices/index), [quote statuses](https://docs.monite.com/accounts-receivable/quotes/index), and [credit note statuses](https://docs.monite.com/accounts-receivable/credit-notes#credit-note-lifecycle).

            To specify multiple statuses, repeat this parameter for each value:
            `status__in=draft&status__in=issued`

        entity_user_id_in : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only receivables created by the entity users with the specified IDs.To specify multiple user IDs, repeat this parameter for each ID:
            `entity_user_id__in=<user1>&entity_user_id__in=<user2>`

            If the request is authenticated using an entity user token, this user must have the `receivable.read.allowed` (rather than `allowed_for_own`) permission to be able to query receivables created by other users.

            IDs of deleted users will still produce results here if those users had associated receivables. Valid but nonexistent user IDs do not raise errors but produce no results.

        sort : typing.Optional[ReceivableCursorFields]
            The field to sort the results by. Typically used together with the `order` parameter.

        tag_ids_in : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only receivables whose [tags](https://docs.monite.com/common/tags) include at least one of the tags with the specified IDs.

            For example, given receivables with the following tags:
            1. tagA
            2. tagB
            3. tagA, tagB
            4. tagC
            5. tagB, tagC


            `tag_ids__in=<tagA>&tag_ids__in=<tagB>` will return receivables 1, 2, 3, and 5.

            Valid but nonexistent tag IDs do not raise errors but produce no results.

        tag_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only receivables whose [tags](https://docs.monite.com/common/tags) include all of the tags with the specified IDs and optionally other tags that are not specified.

            For example, given receivables with the following tags:
            1. tagA
            2. tagB
            3. tagA, tagB
            4. tagC
            5. tagA, tagB, tagC


            `tag_ids=<tagA>&tag_ids=<tagB>` will return receivables 3 and 5.

        product_ids_in : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only receivables whose line items include at least one of the product IDs with the specified IDs.

            To specify multiple product IDs, repeat this parameter for each ID:
            `product_ids__in=<product1>&product_ids__in=<product2>`

            For example, given receivables with the following product IDs:
            1. productA
            2. productB
            3. productA, productB
            4. productC
            5. productB, productC


            `product_ids__in=<productA>&product_ids__in=<productB>` will return receivables 1, 2, 3, and 5.Valid but nonexistent product IDs do not raise errors but produce no results.

        product_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only receivables whose line items include all of the product IDs with the specified IDs and optionally other products that are not specified.

            To specify multiple product IDs, repeat this parameter for each ID:
            `product_ids=<product1>&product_ids=<product2>`

            For example, given receivables with the following product IDs:
            1. productA
            2. productB
            3. productA, productB
            4. productC
            5. productA, productB, productC


            `product_ids=<productA>&product_ids=<productB>` will return receivables 3 and 5.

        project_id_in : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only receivables whose `project_id` include at least one of the project_id with the specified IDs. Valid but nonexistent project IDs do not raise errors but produce no results.

        type : typing.Optional[ReceivableType]
            Return only receivables of the specified type. Use this parameter to get only invoices, or only quotes, or only credit notes.

        document_id : typing.Optional[str]
            Return a receivable with the exact specified document number (case-sensitive). The `document_id` is the user-facing document number such as INV-00042, not to be confused with Monite resource IDs (`id`).

        document_id_contains : typing.Optional[str]
            Return only receivables whose document number (`document_id`) contains the specified string (case-sensitive).

        document_id_icontains : typing.Optional[str]
            Return only receivables whose document number (`document_id`) contains the specified string (case-insensitive).

        issue_date_gt : typing.Optional[dt.datetime]
            Return only non-draft receivables that were issued after the specified date and time. The value must be in the ISO 8601 format `YYYY-MM-DDThh:mm[:ss[.ffffff]][Z|±hh:mm]`.

        issue_date_lt : typing.Optional[dt.datetime]
            Return only non-draft receivables that were issued before the specified date and time.

        issue_date_gte : typing.Optional[dt.datetime]
            Return only non-draft receivables that were issued on or after the specified date and time.

        issue_date_lte : typing.Optional[dt.datetime]
            Return only non-draft receivables that were issued before or on the specified date and time.

        created_at_gt : typing.Optional[dt.datetime]
            Return only receivables created after the specified date and time. The value must be in the ISO 8601 format `YYYY-MM-DDThh:mm[:ss[.ffffff]][Z|±hh:mm]`.

        created_at_lt : typing.Optional[dt.datetime]
            Return only receivables created before the specified date and time.

        created_at_gte : typing.Optional[dt.datetime]
            Return only receivables created on or after the specified date and time.

        created_at_lte : typing.Optional[dt.datetime]
            Return only receivables created before or on the specified date and time.

        counterpart_id : typing.Optional[str]
            Return only receivables created for the counterpart with the specified ID.

            Counterparts that have been deleted but have associated receivables will still return results here because the receivables contain a frozen copy of the counterpart data.

            If the specified counterpart ID does not exist and never existed, no results are returned.

        counterpart_name : typing.Optional[str]
            Return only receivables created for counterparts with the specified name (exact match, case-sensitive). For counterparts of `type` = `individual`, the full name is formatted as `first_name last_name`.

        counterpart_name_contains : typing.Optional[str]
            Return only receivables created for counterparts whose name contains the specified string (case-sensitive).

        counterpart_name_icontains : typing.Optional[str]
            Return only receivables created for counterparts whose name contains the specified string (case-insensitive).

        total_amount : typing.Optional[int]
            Return only receivables with the exact specified total amount. The amount must be specified in the [minor units](https://docs.monite.com/references/currencies#minor-units) of currency. For example, $12.5 is represented as 1250."

        total_amount_gt : typing.Optional[int]
            Return only receivables whose total amount (in minor units) exceeds the specified value.

        total_amount_lt : typing.Optional[int]
            Return only receivables whose total amount (in minor units) is less than the specified value.

        total_amount_gte : typing.Optional[int]
            Return only receivables whose total amount (in minor units) is greater than or equal to the specified value.

        total_amount_lte : typing.Optional[int]
            Return only receivables whose total amount (in minor units) is less than or equal to the specified value.

        discounted_subtotal : typing.Optional[int]
            Return only receivables with the exact specified discounted subtotal. The amount must be specified in the [minor units](https://docs.monite.com/references/currencies#minor-units) of currency. For example, $12.5 is represented as 1250.

        discounted_subtotal_gt : typing.Optional[int]
            Return only receivables whose discounted subtotal (in minor units) is greater than the specified value.

        discounted_subtotal_lt : typing.Optional[int]
            Return only receivables whose discounted subtotal (in minor units) is less than the specified value.

        discounted_subtotal_gte : typing.Optional[int]
            Return only receivables whose discounted subtotal (in minor units) is greater than or equal to the specified value.

        discounted_subtotal_lte : typing.Optional[int]
            Return only receivables whose discounted subtotal (in minor units) is less than or equal to the specified value.

        status : typing.Optional[ReceivablesGetRequestStatus]
            Return only receivables that have the specified status. See the applicable [invoice statuses](https://docs.monite.com/accounts-receivable/invoices/index), [quote statuses](https://docs.monite.com/accounts-receivable/quotes/index), and [credit note statuses](https://docs.monite.com/accounts-receivable/credit-notes#credit-note-lifecycle).

            To query multiple statuses at once, use the `status__in` parameter instead.

        entity_user_id : typing.Optional[str]
            Return only receivables created by the entity users with the specified IDs. To specify multiple user IDs, repeat this parameter for each ID:
            `entity_user_id__in=<user1>&entity_user_id__in=<user2>`

            If the request is authenticated using an entity user token, this user must have the `receivable.read.allowed` (rather than `allowed_for_own`) permission to be able to query receivables created by other users.

            IDs of deleted users will still produce results here if those users had associated receivables. Valid but nonexistent user IDs do not raise errors but produce no results.

        based_on : typing.Optional[str]
            This parameter accepts a quote ID or an invoice ID.

             * Specify a quote ID to find invoices created from this quote.
             * Specify an invoice ID to find credit notes created for this invoice or find recurring invoices created from a base invoice.

            Valid but nonexistent IDs do not raise errors but produce no results.

        due_date_gt : typing.Optional[str]
            Return invoices that are due after the specified date (exclusive, `YYYY-MM-DD`).

            This filter excludes quotes, credit notes, and draft invoices.

        due_date_lt : typing.Optional[str]
            Return invoices that are due before the specified date (exclusive, `YYYY-MM-DD`).

            This filter excludes quotes, credit notes, and draft invoices.

        due_date_gte : typing.Optional[str]
            Return invoices that are due on or after the specified date (`YYYY-MM-DD`).

            This filter excludes quotes, credit notes, and draft invoices.

        due_date_lte : typing.Optional[str]
            Return invoices that are due before or on the specified date (`YYYY-MM-DD`).

            This filter excludes quotes, credit notes, and draft invoices.

        project_id : typing.Optional[str]
            Return only receivables assigned to the project with the specified ID. Valid but nonexistent project IDs do not raise errors but return no results.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReceivablePaginationResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "receivables",
            method="GET",
            params={
                "order": order,
                "limit": limit,
                "pagination_token": pagination_token,
                "id__in": id_in,
                "status__in": status_in,
                "entity_user_id__in": entity_user_id_in,
                "sort": sort,
                "tag_ids__in": tag_ids_in,
                "tag_ids": tag_ids,
                "product_ids__in": product_ids_in,
                "product_ids": product_ids,
                "project_id__in": project_id_in,
                "type": type,
                "document_id": document_id,
                "document_id__contains": document_id_contains,
                "document_id__icontains": document_id_icontains,
                "issue_date__gt": serialize_datetime(issue_date_gt) if issue_date_gt is not None else None,
                "issue_date__lt": serialize_datetime(issue_date_lt) if issue_date_lt is not None else None,
                "issue_date__gte": serialize_datetime(issue_date_gte) if issue_date_gte is not None else None,
                "issue_date__lte": serialize_datetime(issue_date_lte) if issue_date_lte is not None else None,
                "created_at__gt": serialize_datetime(created_at_gt) if created_at_gt is not None else None,
                "created_at__lt": serialize_datetime(created_at_lt) if created_at_lt is not None else None,
                "created_at__gte": serialize_datetime(created_at_gte) if created_at_gte is not None else None,
                "created_at__lte": serialize_datetime(created_at_lte) if created_at_lte is not None else None,
                "counterpart_id": counterpart_id,
                "counterpart_name": counterpart_name,
                "counterpart_name__contains": counterpart_name_contains,
                "counterpart_name__icontains": counterpart_name_icontains,
                "total_amount": total_amount,
                "total_amount__gt": total_amount_gt,
                "total_amount__lt": total_amount_lt,
                "total_amount__gte": total_amount_gte,
                "total_amount__lte": total_amount_lte,
                "discounted_subtotal": discounted_subtotal,
                "discounted_subtotal__gt": discounted_subtotal_gt,
                "discounted_subtotal__lt": discounted_subtotal_lt,
                "discounted_subtotal__gte": discounted_subtotal_gte,
                "discounted_subtotal__lte": discounted_subtotal_lte,
                "status": status,
                "entity_user_id": entity_user_id,
                "based_on": based_on,
                "due_date__gt": due_date_gt,
                "due_date__lt": due_date_lt,
                "due_date__gte": due_date_gte,
                "due_date__lte": due_date_lte,
                "project_id": project_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivablePaginationResponse,
                    parse_obj_as(
                        type_=ReceivablePaginationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create(
        self, *, request: ReceivableFacadeCreatePayload, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ReceivableResponse]:
        """
        Parameters
        ----------
        request : ReceivableFacadeCreatePayload

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReceivableResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "receivables",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=ReceivableFacadeCreatePayload, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableResponse,
                    parse_obj_as(
                        type_=ReceivableResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_receivables_required_fields(
        self,
        *,
        counterpart_id: typing.Optional[str] = None,
        counterpart_billing_address_id: typing.Optional[str] = None,
        counterpart_country: typing.Optional[AllowedCountries] = None,
        counterpart_type: typing.Optional[CounterpartType] = None,
        entity_vat_id_id: typing.Optional[str] = None,
        counterpart_vat_id_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ReceivableRequiredFields]:
        """
        Get field requirements for invoice creation given the entity and counterpart details.

        Parameters
        ----------
        counterpart_id : typing.Optional[str]

        counterpart_billing_address_id : typing.Optional[str]

        counterpart_country : typing.Optional[AllowedCountries]

        counterpart_type : typing.Optional[CounterpartType]

        entity_vat_id_id : typing.Optional[str]

        counterpart_vat_id_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReceivableRequiredFields]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "receivables/required_fields",
            method="GET",
            params={
                "counterpart_id": counterpart_id,
                "counterpart_billing_address_id": counterpart_billing_address_id,
                "counterpart_country": counterpart_country,
                "counterpart_type": counterpart_type,
                "entity_vat_id_id": entity_vat_id_id,
                "counterpart_vat_id_id": counterpart_vat_id_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableRequiredFields,
                    parse_obj_as(
                        type_=ReceivableRequiredFields,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def post_receivables_search(
        self,
        *,
        based_on: typing.Optional[str] = OMIT,
        counterpart_id: typing.Optional[str] = OMIT,
        counterpart_name: typing.Optional[str] = OMIT,
        counterpart_name_contains: typing.Optional[str] = OMIT,
        counterpart_name_icontains: typing.Optional[str] = OMIT,
        created_at_gt: typing.Optional[dt.datetime] = OMIT,
        created_at_gte: typing.Optional[dt.datetime] = OMIT,
        created_at_lt: typing.Optional[dt.datetime] = OMIT,
        created_at_lte: typing.Optional[dt.datetime] = OMIT,
        discounted_subtotal: typing.Optional[int] = OMIT,
        discounted_subtotal_gt: typing.Optional[int] = OMIT,
        discounted_subtotal_gte: typing.Optional[int] = OMIT,
        discounted_subtotal_lt: typing.Optional[int] = OMIT,
        discounted_subtotal_lte: typing.Optional[int] = OMIT,
        document_id: typing.Optional[str] = OMIT,
        document_id_contains: typing.Optional[str] = OMIT,
        document_id_icontains: typing.Optional[str] = OMIT,
        due_date_gt: typing.Optional[str] = OMIT,
        due_date_gte: typing.Optional[str] = OMIT,
        due_date_lt: typing.Optional[str] = OMIT,
        due_date_lte: typing.Optional[str] = OMIT,
        entity_user_id: typing.Optional[str] = OMIT,
        entity_user_id_in: typing.Optional[typing.Sequence[str]] = OMIT,
        id_in: typing.Optional[typing.Sequence[str]] = OMIT,
        issue_date_gt: typing.Optional[dt.datetime] = OMIT,
        issue_date_gte: typing.Optional[dt.datetime] = OMIT,
        issue_date_lt: typing.Optional[dt.datetime] = OMIT,
        issue_date_lte: typing.Optional[dt.datetime] = OMIT,
        limit: typing.Optional[int] = OMIT,
        order: typing.Optional[OrderEnum] = OMIT,
        pagination_token: typing.Optional[str] = OMIT,
        product_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        product_ids_in: typing.Optional[typing.Sequence[str]] = OMIT,
        project_id: typing.Optional[str] = OMIT,
        project_id_in: typing.Optional[typing.Sequence[str]] = OMIT,
        sort: typing.Optional[ReceivableCursorFields2] = OMIT,
        status: typing.Optional[ReceivablesSearchRequestStatus] = OMIT,
        status_in: typing.Optional[typing.Sequence[str]] = OMIT,
        tag_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        tag_ids_in: typing.Optional[typing.Sequence[str]] = OMIT,
        total_amount: typing.Optional[int] = OMIT,
        total_amount_gt: typing.Optional[int] = OMIT,
        total_amount_gte: typing.Optional[int] = OMIT,
        total_amount_lt: typing.Optional[int] = OMIT,
        total_amount_lte: typing.Optional[int] = OMIT,
        type: typing.Optional[ReceivableType] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ReceivablePaginationResponse]:
        """
        This is a POST version of the `GET /receivables` endpoint. Use it to send search and filter parameters in the request body instead of the URL query string in case the query is too long and exceeds the URL length limit of your HTTP client.

        Parameters
        ----------
        based_on : typing.Optional[str]
            This parameter accepts a quote ID or an invoice ID.

            * Specify a quote ID to find invoices created from this quote.
            * Specify an invoice ID to find credit notes created for this invoice.

            Valid but nonexistent IDs do not raise errors but produce no results.

        counterpart_id : typing.Optional[str]
            Return only receivables created for the counterpart with the specified ID.

            Counterparts that have been deleted but have associated receivables will still return results here because the receivables contain a frozen copy of the counterpart data.

            If the specified counterpart ID does not exist and never existed, no results are returned.

        counterpart_name : typing.Optional[str]
            Return only receivables created for counterparts with the specified name (exact match, case-sensitive). For counterparts of `type` = `individual`, the full name is formatted as `first_name last_name`.

        counterpart_name_contains : typing.Optional[str]
            Return only receivables created for counterparts whose name contains the specified string (case-sensitive).

        counterpart_name_icontains : typing.Optional[str]
            Return only receivables created for counterparts whose name contains the specified string (case-insensitive).

        created_at_gt : typing.Optional[dt.datetime]
            Return only receivables created after the specified date and time. The value must be in the ISO 8601 format `YYYY-MM-DDThh:mm[:ss[.ffffff]][Z|±hh:mm]`.

        created_at_gte : typing.Optional[dt.datetime]
            Return only receivables created on or after the specified date and time.

        created_at_lt : typing.Optional[dt.datetime]
            Return only receivables created before the specified date and time.

        created_at_lte : typing.Optional[dt.datetime]
            Return only receivables created before or on the specified date and time.

        discounted_subtotal : typing.Optional[int]
            Return only receivables with the exact specified discounted subtotal. The amount must be specified in the [minor units](https://docs.monite.com/references/currencies#minor-units) of currency. For example, $12.5 is represented as 1250.

        discounted_subtotal_gt : typing.Optional[int]
            Return only receivables whose discounted subtotal (in minor units) is greater than the specified value.

        discounted_subtotal_gte : typing.Optional[int]
            Return only receivables whose discounted subtotal (in minor units) is greater than or equal to the specified value.

        discounted_subtotal_lt : typing.Optional[int]
            Return only receivables whose discounted subtotal (in minor units) is less than the specified value.

        discounted_subtotal_lte : typing.Optional[int]
            Return only receivables whose discounted subtotal (in minor units) is less than or equal to the specified value.

        document_id : typing.Optional[str]
            Return a receivable with the exact specified document number (case-sensitive). The `document_id` is the user-facing document number such as INV-00042, not to be confused with Monite resource IDs (`id`).

        document_id_contains : typing.Optional[str]
            Return only receivables whose document number (`document_id`) contains the specified string (case-sensitive).

        document_id_icontains : typing.Optional[str]
            Return only receivables whose document number (`document_id`) contains the specified string (case-insensitive).

        due_date_gt : typing.Optional[str]
            Return invoices that are due after the specified date (exclusive, `YYYY-MM-DD`).

            This filter excludes quotes, credit notes, and draft invoices.

        due_date_gte : typing.Optional[str]
            Return invoices that are due on or after the specified date (`YYYY-MM-DD`).

            This filter excludes quotes, credit notes, and draft invoices.

        due_date_lt : typing.Optional[str]
            Return invoices that are due before the specified date (exclusive, `YYYY-MM-DD`).

            This filter excludes quotes, credit notes, and draft invoices.

        due_date_lte : typing.Optional[str]
            Return invoices that are due before or on the specified date (`YYYY-MM-DD`).

            This filter excludes quotes, credit notes, and draft invoices.

        entity_user_id : typing.Optional[str]
            Return only receivables created by the entity user with the specified ID. To query receivables by multiple user IDs at once, use the `entity_user_id__in` parameter instead.

            If the request is authenticated using an entity user token, this user must have the `receivable.read.allowed` (rather than `allowed_for_own`) permission to be able to query receivables created by other users.

            IDs of deleted users will still produce results here if those users had associated receivables. Valid but nonexistent user IDs do not raise errors but produce no results.

        entity_user_id_in : typing.Optional[typing.Sequence[str]]
            Return only receivables created by the entity users with the specified IDs.

            If the request is authenticated using an entity user token, this user must have the `receivable.read.allowed` (rather than `allowed_for_own`) permission to be able to query receivables created by other users.

            IDs of deleted users will still produce results here if those users had associated receivables. Valid but nonexistent user IDs do not raise errors but produce no results.

        id_in : typing.Optional[typing.Sequence[str]]
            Return only receivables with the specified IDs. Valid but nonexistent IDs do not raise errors but produce no results.

        issue_date_gt : typing.Optional[dt.datetime]
            Return only non-draft receivables that were issued after the specified date and time. The value must be in the ISO 8601 format `YYYY-MM-DDThh:mm[:ss[.ffffff]][Z|±hh:mm]`.

        issue_date_gte : typing.Optional[dt.datetime]
            Return only non-draft receivables that were issued on or after the specified date and time.

        issue_date_lt : typing.Optional[dt.datetime]
            Return only non-draft receivables that were issued before the specified date and time.

        issue_date_lte : typing.Optional[dt.datetime]
            Return only non-draft receivables that were issued before or on the specified date and time.

        limit : typing.Optional[int]
            The number of items (0 .. 250) to return in a single page of the response. Default is 100. The response may contain fewer items if it is the last or only page.

            When using pagination with a non-default limit, you must provide the `limit` value alongside `pagination_token` in all subsequent pagination requests. Unlike other pagination parameters, `limit` is not inferred from `pagination_token`.

        order : typing.Optional[OrderEnum]
            Sort order (ascending by default). Typically used together with the `sort` parameter.

        pagination_token : typing.Optional[str]
            A pagination token obtained from a previous call to `GET /receivables` or `POST /receivables/search`. Use it to get the next or previous page of results for your initial query. If `pagination_token` is specified, all other parameters except `limit` are ignored and inferred from the initial query.

            If not specified, the first page of results will be returned.

        product_ids : typing.Optional[typing.Sequence[str]]
            Return only receivables with line items containing all of the products with the specified IDs and optionally other products that are not specified.

            For example, given receivables that contain the following products:

             1. productA
             2. productB
             3. productA, productB
             4. productC
             5. productA, productB, productC

            `product_ids` = `[productA, productB]` will return receivables 3 and 5.

            Valid but nonexistent product IDs do not raise errors but produce no results.

        product_ids_in : typing.Optional[typing.Sequence[str]]
            Return only receivables with line items containing at least one of the products with the specified IDs.

            For example, given receivables that contain the following products:

             1. productA
             2. productB
             3. productA, productB
             4. productC
             5. productB, productC

            `product_ids__in` = `[productA, productB]` will return receivables 1, 2, 3, and 5.

            Valid but nonexistent product IDs do not raise errors but produce no results.

        project_id : typing.Optional[str]
            Return only receivables assigned to the project with the specified ID. Valid but nonexistent project IDs do not raise errors but return no results.

        project_id_in : typing.Optional[typing.Sequence[str]]
            Return only receivables that belong to one of the projects with the specified IDs. Valid but nonexistent project IDs do not raise errors but produce no results.

        sort : typing.Optional[ReceivableCursorFields2]
            The field to sort the results by. Typically used together with the `order` parameter.

        status : typing.Optional[ReceivablesSearchRequestStatus]
            Return only receivables that have the specified status. See the applicable [invoice statuses](https://docs.monite.com/accounts-receivable/invoices/index), [quote statuses](https://docs.monite.com/accounts-receivable/quotes/index), and [credit note statuses](https://docs.monite.com/accounts-receivable/credit-notes#credit-note-lifecycle).

            To query multiple statuses at once, use the `status__in` parameter instead.

        status_in : typing.Optional[typing.Sequence[str]]
            Return only receivables that have the specified statuses. See the applicable [invoice statuses](https://docs.monite.com/accounts-receivable/invoices/index), [quote statuses](https://docs.monite.com/accounts-receivable/quotes/index), and [credit note statuses](https://docs.monite.com/accounts-receivable/credit-notes#credit-note-lifecycle).

        tag_ids : typing.Optional[typing.Sequence[str]]
            Return only receivables whose [tags](https://docs.monite.com/common/tags) include all of the tags with the specified IDs and optionally other tags that are not specified.

            For example, given receivables with the following tags:

             1. tagA
             2. tagB
             3. tagA, tagB
             4. tagC
             5. tagA, tagB, tagC

            `tag_ids` = `[tagA, tagB]` will return receivables 3 and 5.

        tag_ids_in : typing.Optional[typing.Sequence[str]]
            Return only receivables whose [tags](https://docs.monite.com/common/tags) include at least one of the tags with the specified IDs.

            For example, given receivables with the following tags:

             1. tagA
             2. tagB
             3. tagA, tagB
             4. tagC
             5. tagB, tagC

            `tag_ids__in` = `[tagA, tagB]` will return receivables 1, 2, 3, and 5.

            Valid but nonexistent tag IDs do not raise errors but produce no results.

        total_amount : typing.Optional[int]
            Return only receivables with the exact specified total amount. The amount must be specified in the [minor units](https://docs.monite.com/references/currencies#minor-units) of currency. For example, $12.5 is represented as 1250.

        total_amount_gt : typing.Optional[int]
            Return only receivables whose total amount (in minor units) exceeds the specified value.

        total_amount_gte : typing.Optional[int]
            Return only receivables whose total amount (in minor units) is greater than or equal to the specified value.

        total_amount_lt : typing.Optional[int]
            Return only receivables whose total amount (in minor units) is less than the specified value.

        total_amount_lte : typing.Optional[int]
            Return only receivables whose total amount (in minor units) is less than or equal to the specified value.

        type : typing.Optional[ReceivableType]
            Return only receivables of the specified type. Use this parameter to get only invoices, or only quotes, or only credit notes.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReceivablePaginationResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "receivables/search",
            method="POST",
            json={
                "based_on": based_on,
                "counterpart_id": counterpart_id,
                "counterpart_name": counterpart_name,
                "counterpart_name__contains": counterpart_name_contains,
                "counterpart_name__icontains": counterpart_name_icontains,
                "created_at__gt": created_at_gt,
                "created_at__gte": created_at_gte,
                "created_at__lt": created_at_lt,
                "created_at__lte": created_at_lte,
                "discounted_subtotal": discounted_subtotal,
                "discounted_subtotal__gt": discounted_subtotal_gt,
                "discounted_subtotal__gte": discounted_subtotal_gte,
                "discounted_subtotal__lt": discounted_subtotal_lt,
                "discounted_subtotal__lte": discounted_subtotal_lte,
                "document_id": document_id,
                "document_id__contains": document_id_contains,
                "document_id__icontains": document_id_icontains,
                "due_date__gt": due_date_gt,
                "due_date__gte": due_date_gte,
                "due_date__lt": due_date_lt,
                "due_date__lte": due_date_lte,
                "entity_user_id": entity_user_id,
                "entity_user_id__in": entity_user_id_in,
                "id__in": id_in,
                "issue_date__gt": issue_date_gt,
                "issue_date__gte": issue_date_gte,
                "issue_date__lt": issue_date_lt,
                "issue_date__lte": issue_date_lte,
                "limit": limit,
                "order": order,
                "pagination_token": pagination_token,
                "product_ids": product_ids,
                "product_ids__in": product_ids_in,
                "project_id": project_id,
                "project_id__in": project_id_in,
                "sort": sort,
                "status": status,
                "status__in": status_in,
                "tag_ids": tag_ids,
                "tag_ids__in": tag_ids_in,
                "total_amount": total_amount,
                "total_amount__gt": total_amount_gt,
                "total_amount__gte": total_amount_gte,
                "total_amount__lt": total_amount_lt,
                "total_amount__lte": total_amount_lte,
                "type": type,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivablePaginationResponse,
                    parse_obj_as(
                        type_=ReceivablePaginationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_variables(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ReceivableTemplatesVariablesObjectList]:
        """
        Get a list of placeholders that can be used in email templates for customization.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReceivableTemplatesVariablesObjectList]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "receivables/variables",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableTemplatesVariablesObjectList,
                    parse_obj_as(
                        type_=ReceivableTemplatesVariablesObjectList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_by_id(
        self, receivable_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ReceivableResponse]:
        """
        Returns the details of an existing accounts receivable invoice, quote, or credit note with the specified ID.

        The response fields vary depending on the document type. Use the `type` field to distinguish between different document types.

        Entity users with the `receivable.read.allowed_for_own` permission (rather than `allowed`) can access only documents that they created themselves.

        Parameters
        ----------
        receivable_id : str
            ID of an existing invoice, quote, or credit note that you want to retrieve.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReceivableResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableResponse,
                    parse_obj_as(
                        type_=ReceivableResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_by_id(
        self, receivable_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        receivable_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_by_id(
        self,
        receivable_id: str,
        *,
        request: ReceivableUpdatePayload,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ReceivableResponse]:
        """
        Parameters
        ----------
        receivable_id : str

        request : ReceivableUpdatePayload

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReceivableResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}",
            method="PATCH",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=ReceivableUpdatePayload, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableResponse,
                    parse_obj_as(
                        type_=ReceivableResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def accept_by_id(
        self,
        receivable_id: str,
        *,
        signature: typing.Optional[Signature] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SuccessResult]:
        """
        Only quotes in the `issued` status can be accepted.

        When a quote is accepted, Monite automatically creates a draft invoice based on this quote. To find the newly created invoice, use `GET /receivables?based_on=QUOTE_ID`.

        Parameters
        ----------
        receivable_id : str

        signature : typing.Optional[Signature]
            The counterpart's signature. Required if the quote field `signature_required` is `true`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SuccessResult]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/accept",
            method="POST",
            json={
                "signature": convert_and_respect_annotation_metadata(
                    object_=signature, annotation=Signature, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SuccessResult,
                    parse_obj_as(
                        type_=SuccessResult,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def cancel_by_id(
        self, receivable_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        receivable_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/cancel",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def clone_by_id(
        self, receivable_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ReceivableResponse]:
        """
        Creates a copy of an existing accounts receivable invoice or quote. The original document can be in any status. The cloned document will have the `draft` status.

        Cloning a document requires that all of the referenced resource IDs (counterpart ID, product IDs, and others) still exist.

        Most of the original document's data is copied as is, with a few exceptions:

         * Some fields are not copied: `attachments`, `document_id`, `issue_date`, quote `expiry_date`.
         * Counterpart details, entity bank account details, and entity VAT number are fetched anew from their corresponding IDs.
           This means, for example, that if the counterpart details have been changed since the original invoice or quote was created,
           the cloned document will use the current counterpart details rather than the old details from the original document.

        Parameters
        ----------
        receivable_id : str
            ID of an existing invoice or quote that you want to clone.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReceivableResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/clone",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableResponse,
                    parse_obj_as(
                        type_=ReceivableResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def decline_by_id(
        self,
        receivable_id: str,
        *,
        comment: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SuccessResult]:
        """
        Only quotes in the `issued` status can be declined.

        Parameters
        ----------
        receivable_id : str

        comment : typing.Optional[str]
            Field with a comment on why the client declined this Quote

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SuccessResult]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/decline",
            method="POST",
            json={
                "comment": comment,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SuccessResult,
                    parse_obj_as(
                        type_=SuccessResult,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_history(
        self,
        receivable_id: str,
        *,
        order: typing.Optional[OrderEnum] = None,
        limit: typing.Optional[int] = None,
        pagination_token: typing.Optional[str] = None,
        sort: typing.Optional[ReceivableHistoryCursorFields] = None,
        event_type_in: typing.Optional[
            typing.Union[ReceivableHistoryEventTypeEnum, typing.Sequence[ReceivableHistoryEventTypeEnum]]
        ] = None,
        entity_user_id_in: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        timestamp_gt: typing.Optional[dt.datetime] = None,
        timestamp_lt: typing.Optional[dt.datetime] = None,
        timestamp_gte: typing.Optional[dt.datetime] = None,
        timestamp_lte: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ReceivableHistoryPaginationResponse]:
        """
        Returns the history of the specified accounts receivable document. The history contains all revisions of the document, status updates, and other events that occurred during the document's lifecycle. For more information, see [Document history](https://docs.monite.com/accounts-receivable/document-history).

        You can filter the history by the date range and event type. Events are sorted from oldest to newest by default.

        Parameters
        ----------
        receivable_id : str
            ID of the accounts receivable document whose history you want to get.

        order : typing.Optional[OrderEnum]
            Sort order (ascending by default). Typically used together with the `sort` parameter.

        limit : typing.Optional[int]
            The number of items (0 .. 100) to return in a single page of the response. The response may contain fewer items if it is the last or only page.

        pagination_token : typing.Optional[str]
            A pagination token obtained from a previous call to this endpoint. Use it to get the next or previous page of results for your initial query. If `pagination_token` is specified, all other query parameters are ignored and inferred from the initial query.

            If not specified, the first page of results will be returned.

        sort : typing.Optional[ReceivableHistoryCursorFields]
            The field to sort the results by. Typically used together with the `order` parameter.

        event_type_in : typing.Optional[typing.Union[ReceivableHistoryEventTypeEnum, typing.Sequence[ReceivableHistoryEventTypeEnum]]]
            Return only the specified [event types](https://docs.monite.com/accounts-receivable/document-history#event-types). To include multiple types, repeat this parameter for each value:
            `event_type__in=receivable_updated&event_type__in=status_changed`

        entity_user_id_in : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only events caused by the entity users with the specified IDs. To specify multiple user IDs, repeat this parameter for each ID:
            `entity_user_id__in=<user1>&entity_user_id__in=<user2>`

        timestamp_gt : typing.Optional[dt.datetime]
            Return only events that occurred after the specified date and time. The value must be in the ISO 8601 format `YYYY-MM-DDThh:mm[:ss[.ffffff]][Z|±hh:mm]`.

        timestamp_lt : typing.Optional[dt.datetime]
            Return only events that occurred before the specified date and time.

        timestamp_gte : typing.Optional[dt.datetime]
            Return only events that occurred on or after the specified date and time.

        timestamp_lte : typing.Optional[dt.datetime]
            Return only events that occurred before or on the specified date and time.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReceivableHistoryPaginationResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/history",
            method="GET",
            params={
                "order": order,
                "limit": limit,
                "pagination_token": pagination_token,
                "sort": sort,
                "event_type__in": event_type_in,
                "entity_user_id__in": entity_user_id_in,
                "timestamp__gt": serialize_datetime(timestamp_gt) if timestamp_gt is not None else None,
                "timestamp__lt": serialize_datetime(timestamp_lt) if timestamp_lt is not None else None,
                "timestamp__gte": serialize_datetime(timestamp_gte) if timestamp_gte is not None else None,
                "timestamp__lte": serialize_datetime(timestamp_lte) if timestamp_lte is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableHistoryPaginationResponse,
                    parse_obj_as(
                        type_=ReceivableHistoryPaginationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_history_by_id(
        self, receivable_history_id: str, receivable_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ReceivableHistoryResponse]:
        """
        Returns a single record from the change history of the specified accounts receivable document.

        Parameters
        ----------
        receivable_history_id : str
            ID of the history record to return. You can get these IDs from `GET /receivables/{receivable_id}/history`.

        receivable_id : str
            ID of the accounts receivable document whose history you want to get.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReceivableHistoryResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/history/{jsonable_encoder(receivable_history_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableHistoryResponse,
                    parse_obj_as(
                        type_=ReceivableHistoryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def issue_by_id(
        self, receivable_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ReceivableResponse]:
        """
        Parameters
        ----------
        receivable_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReceivableResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/issue",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableResponse,
                    parse_obj_as(
                        type_=ReceivableResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_line_items_by_id(
        self,
        receivable_id: str,
        *,
        data: typing.Sequence[LineItem],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[LineItemsResponse]:
        """
        Replace all line items of an existing invoice or quote with a new list of line items.

        Parameters
        ----------
        receivable_id : str

        data : typing.Sequence[LineItem]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[LineItemsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/line_items",
            method="PUT",
            json={
                "data": convert_and_respect_annotation_metadata(
                    object_=data, annotation=typing.Sequence[LineItem], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    LineItemsResponse,
                    parse_obj_as(
                        type_=LineItemsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_mails(
        self,
        receivable_id: str,
        *,
        order: typing.Optional[OrderEnum] = None,
        limit: typing.Optional[int] = None,
        pagination_token: typing.Optional[str] = None,
        sort: typing.Optional[ReceivableMailCursorFields] = None,
        status: typing.Optional[ReceivableMailStatusEnum] = None,
        status_in: typing.Optional[
            typing.Union[ReceivableMailStatusEnum, typing.Sequence[ReceivableMailStatusEnum]]
        ] = None,
        created_at_gt: typing.Optional[dt.datetime] = None,
        created_at_lt: typing.Optional[dt.datetime] = None,
        created_at_gte: typing.Optional[dt.datetime] = None,
        created_at_lte: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ReceivableMailPaginationResponse]:
        """
        Parameters
        ----------
        receivable_id : str

        order : typing.Optional[OrderEnum]
            Sort order (ascending by default). Typically used together with the `sort` parameter.

        limit : typing.Optional[int]
            The number of items (0 .. 100) to return in a single page of the response. The response may contain fewer items if it is the last or only page.

        pagination_token : typing.Optional[str]
            A pagination token obtained from a previous call to this endpoint. Use it to get the next or previous page of results for your initial query. If `pagination_token` is specified, all other query parameters are ignored and inferred from the initial query.

            If not specified, the first page of results will be returned.

        sort : typing.Optional[ReceivableMailCursorFields]
            The field to sort the results by. Typically used together with the `order` parameter.

        status : typing.Optional[ReceivableMailStatusEnum]

        status_in : typing.Optional[typing.Union[ReceivableMailStatusEnum, typing.Sequence[ReceivableMailStatusEnum]]]

        created_at_gt : typing.Optional[dt.datetime]

        created_at_lt : typing.Optional[dt.datetime]

        created_at_gte : typing.Optional[dt.datetime]

        created_at_lte : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReceivableMailPaginationResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/mails",
            method="GET",
            params={
                "order": order,
                "limit": limit,
                "pagination_token": pagination_token,
                "sort": sort,
                "status": status,
                "status__in": status_in,
                "created_at__gt": serialize_datetime(created_at_gt) if created_at_gt is not None else None,
                "created_at__lt": serialize_datetime(created_at_lt) if created_at_lt is not None else None,
                "created_at__gte": serialize_datetime(created_at_gte) if created_at_gte is not None else None,
                "created_at__lte": serialize_datetime(created_at_lte) if created_at_lte is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableMailPaginationResponse,
                    parse_obj_as(
                        type_=ReceivableMailPaginationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_mail_by_id(
        self, receivable_id: str, mail_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ReceivableMailResponse]:
        """
        Parameters
        ----------
        receivable_id : str

        mail_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReceivableMailResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/mails/{jsonable_encoder(mail_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableMailResponse,
                    parse_obj_as(
                        type_=ReceivableMailResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def mark_as_paid_by_id(
        self,
        receivable_id: str,
        *,
        comment: typing.Optional[str] = OMIT,
        paid_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ReceivableResponse]:
        """
        Parameters
        ----------
        receivable_id : str

        comment : typing.Optional[str]
            Optional comment explaining how the payment was made.

        paid_at : typing.Optional[dt.datetime]
            Date and time when the invoice was paid.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReceivableResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/mark_as_paid",
            method="POST",
            json={
                "comment": comment,
                "paid_at": paid_at,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableResponse,
                    parse_obj_as(
                        type_=ReceivableResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def mark_as_partially_paid_by_id(
        self,
        receivable_id: str,
        *,
        amount_paid: int,
        comment: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ReceivableResponse]:
        """
        Deprecated. Use `POST /payment_records` to record an invoice payment.

        Parameters
        ----------
        receivable_id : str

        amount_paid : int
            How much has been paid on the invoice (in minor units).

        comment : typing.Optional[str]
            Optional comment explaining how the payment was made.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReceivableResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/mark_as_partially_paid",
            method="POST",
            json={
                "amount_paid": amount_paid,
                "comment": comment,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableResponse,
                    parse_obj_as(
                        type_=ReceivableResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def mark_as_uncollectible_by_id(
        self,
        receivable_id: str,
        *,
        comment: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ReceivableResponse]:
        """
        Parameters
        ----------
        receivable_id : str

        comment : typing.Optional[str]
            Optional comment explains why the Invoice goes uncollectible.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReceivableResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/mark_as_uncollectible",
            method="POST",
            json={
                "comment": comment,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableResponse,
                    parse_obj_as(
                        type_=ReceivableResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_pdf_link_by_id(
        self, receivable_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ReceivableFileUrl]:
        """
        Parameters
        ----------
        receivable_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReceivableFileUrl]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/pdf_link",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableFileUrl,
                    parse_obj_as(
                        type_=ReceivableFileUrl,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def preview_by_id(
        self,
        receivable_id: str,
        *,
        body_text: str,
        subject_text: str,
        language: typing.Optional[LanguageCodeEnum] = OMIT,
        type: typing.Optional[ReceivablesPreviewTypeEnum] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ReceivablePreviewResponse]:
        """
        You can preview emails only for documents in the following statuses:

         * Invoices: `draft`, `issued`, `overdue`, `partially_paid`, `paid`.
           In the [non-compliant mode](https://docs.monite.com/accounts-receivable/regulatory-compliance/invoice-compliance): also `canceled`.
         * Quotes: `draft`, `issued`.
         * Credit notes: `draft`, `issued`.

        Parameters
        ----------
        receivable_id : str

        body_text : str
            Body text of the content

        subject_text : str
            Subject text of the content

        language : typing.Optional[LanguageCodeEnum]
            Language code for localization purposes

        type : typing.Optional[ReceivablesPreviewTypeEnum]
            The type of the preview document.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReceivablePreviewResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/preview",
            method="POST",
            json={
                "body_text": body_text,
                "language": language,
                "subject_text": subject_text,
                "type": type,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivablePreviewResponse,
                    parse_obj_as(
                        type_=ReceivablePreviewResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def send_by_id(
        self,
        receivable_id: str,
        *,
        body_text: str,
        subject_text: str,
        recipients: typing.Optional[Recipients] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ReceivableSendResponse]:
        """
        Only documents in the following statuses can be sent via email:

         * Invoices: `draft`, `issued`, `overdue`, `partially_paid`, `paid`.
           In the [non-compliant mode](https://docs.monite.com/accounts-receivable/regulatory-compliance/invoice-compliance): also `canceled`.
         * Quotes: `draft`, `issued`.
         * Credit notes: `draft`, `issued`.

        Draft documents are automatically moved to the `issued` status before sending.

        For more information, see [Send an invoice via email](https://docs.monite.com/accounts-receivable/invoices/create#send-via-email).

        Parameters
        ----------
        receivable_id : str

        body_text : str
            Body text of the content

        subject_text : str
            Subject text of the content

        recipients : typing.Optional[Recipients]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReceivableSendResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/send",
            method="POST",
            json={
                "body_text": body_text,
                "recipients": convert_and_respect_annotation_metadata(
                    object_=recipients, annotation=Recipients, direction="write"
                ),
                "subject_text": subject_text,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableSendResponse,
                    parse_obj_as(
                        type_=ReceivableSendResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def send_test_reminder_by_id(
        self,
        receivable_id: str,
        *,
        reminder_type: ReminderTypeEnum,
        recipients: typing.Optional[Recipients] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ReceivablesSendResponse]:
        """
        Parameters
        ----------
        receivable_id : str

        reminder_type : ReminderTypeEnum
            The type of the reminder to be sent.

        recipients : typing.Optional[Recipients]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReceivablesSendResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/send_test_reminder",
            method="POST",
            json={
                "recipients": convert_and_respect_annotation_metadata(
                    object_=recipients, annotation=Recipients, direction="write"
                ),
                "reminder_type": reminder_type,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivablesSendResponse,
                    parse_obj_as(
                        type_=ReceivablesSendResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def verify_by_id(
        self, receivable_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ReceivablesVerifyResponse]:
        """
        Parameters
        ----------
        receivable_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReceivablesVerifyResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/verify",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivablesVerifyResponse,
                    parse_obj_as(
                        type_=ReceivablesVerifyResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawReceivablesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get(
        self,
        *,
        order: typing.Optional[OrderEnum] = None,
        limit: typing.Optional[int] = None,
        pagination_token: typing.Optional[str] = None,
        id_in: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        status_in: typing.Optional[
            typing.Union[ReceivablesGetRequestStatusInItem, typing.Sequence[ReceivablesGetRequestStatusInItem]]
        ] = None,
        entity_user_id_in: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        sort: typing.Optional[ReceivableCursorFields] = None,
        tag_ids_in: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        tag_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        product_ids_in: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        product_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        project_id_in: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        type: typing.Optional[ReceivableType] = None,
        document_id: typing.Optional[str] = None,
        document_id_contains: typing.Optional[str] = None,
        document_id_icontains: typing.Optional[str] = None,
        issue_date_gt: typing.Optional[dt.datetime] = None,
        issue_date_lt: typing.Optional[dt.datetime] = None,
        issue_date_gte: typing.Optional[dt.datetime] = None,
        issue_date_lte: typing.Optional[dt.datetime] = None,
        created_at_gt: typing.Optional[dt.datetime] = None,
        created_at_lt: typing.Optional[dt.datetime] = None,
        created_at_gte: typing.Optional[dt.datetime] = None,
        created_at_lte: typing.Optional[dt.datetime] = None,
        counterpart_id: typing.Optional[str] = None,
        counterpart_name: typing.Optional[str] = None,
        counterpart_name_contains: typing.Optional[str] = None,
        counterpart_name_icontains: typing.Optional[str] = None,
        total_amount: typing.Optional[int] = None,
        total_amount_gt: typing.Optional[int] = None,
        total_amount_lt: typing.Optional[int] = None,
        total_amount_gte: typing.Optional[int] = None,
        total_amount_lte: typing.Optional[int] = None,
        discounted_subtotal: typing.Optional[int] = None,
        discounted_subtotal_gt: typing.Optional[int] = None,
        discounted_subtotal_lt: typing.Optional[int] = None,
        discounted_subtotal_gte: typing.Optional[int] = None,
        discounted_subtotal_lte: typing.Optional[int] = None,
        status: typing.Optional[ReceivablesGetRequestStatus] = None,
        entity_user_id: typing.Optional[str] = None,
        based_on: typing.Optional[str] = None,
        due_date_gt: typing.Optional[str] = None,
        due_date_lt: typing.Optional[str] = None,
        due_date_gte: typing.Optional[str] = None,
        due_date_lte: typing.Optional[str] = None,
        project_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ReceivablePaginationResponse]:
        """
        Returns a list of [accounts receivable](https://docs.monite.com/accounts-receivable/index) documents - invoices, quotes, and credit notes - of the specified entity.

        Results can be filtered by amount, counterpart, due date, and other criteria. Multiple filters are combined using logical AND unless specified otherwise. If no documents matching the search criteria are found, the endpoint returns a successful response with an empty `data` array.

        This endpoint supports [pagination](https://docs.monite.com/api/concepts/pagination-sorting-filtering) and sorting. By default, results are sorted by the creation date in ascending order (from oldest to newest).

        #### Examples

        ##### Invoices

        * Get all overdue invoices:
            ```
            GET /receivables?type=invoice&status=overdue
            ```

        * Get all invoices created for the counterpart named "Solarwind" (case-insensitive):

            ```
            GET /receivables?type=invoice?counterpart_name__icontains=Solarwind
            ```

        * Get invoices whose total amount starts from 500 EUR:

            ```
            GET /receivables?type=invoice&total_amount__gte=50000
            ```

        * Get invoices that are due for payment in September 2024:

            ```
            GET /receivables?type=invoice&due_date__gte=2024-09-01T00:00:00Z&due_date__lt=2024-10-01T00:00:00Z
            ```

        * Get invoices created on or after September 1, 2024:

            ```
            GET /receivables?type=invoice&created_at__gte=2024-09-01T00:00:00Z
            ```

        * Find an invoice created from a specific quote:

            ```
            GET /receivables?type=invoice?based_on=QUOTE_ID
            ```

        ##### Quotes

        * Get the latest created quote:

            ```
            GET /receivables?type=quote&sort=created_at&order=desc&limit=1
            ```

        * Get the latest issued quote:

            ```
            GET /receivables?type=quote&sort=issue_date&order=desc&limit=1
            ```

        ##### Credit notes

        * Find all credit notes created for a specific invoice:

            ```
            GET /receivables?type=credit_note?based_on=INVOICE_ID
            ```

        Parameters
        ----------
        order : typing.Optional[OrderEnum]
            Sort order (ascending by default). Typically used together with the `sort` parameter.

        limit : typing.Optional[int]
            The number of items (0 .. 250) to return in a single page of the response. Default is 100. The response may contain fewer items if it is the last or only page.

            When using pagination with a non-default `limit`, you must provide the `limit` value alongside `pagination_token` in all subsequent pagination requests. Unlike other query parameters, `limit` is not inferred from `pagination_token`.

        pagination_token : typing.Optional[str]
            A pagination token obtained from a previous call to this endpoint. Use it to get the next or previous page of results for your initial query. If `pagination_token` is specified, all other query parameters except `limit` are ignored and inferred from the initial query.

            If not specified, the first page of results will be returned.

        id_in : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only receivables with the specified IDs. Valid but nonexistent IDs do not raise errors but produce no results.

            To specify multiple IDs, repeat this parameter for each value:
            `id__in=<id1>&id__in=<id2>`

        status_in : typing.Optional[typing.Union[ReceivablesGetRequestStatusInItem, typing.Sequence[ReceivablesGetRequestStatusInItem]]]
            Return only receivables that have the specified statuses. See the applicable [invoice statuses](https://docs.monite.com/accounts-receivable/invoices/index), [quote statuses](https://docs.monite.com/accounts-receivable/quotes/index), and [credit note statuses](https://docs.monite.com/accounts-receivable/credit-notes#credit-note-lifecycle).

            To specify multiple statuses, repeat this parameter for each value:
            `status__in=draft&status__in=issued`

        entity_user_id_in : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only receivables created by the entity users with the specified IDs.To specify multiple user IDs, repeat this parameter for each ID:
            `entity_user_id__in=<user1>&entity_user_id__in=<user2>`

            If the request is authenticated using an entity user token, this user must have the `receivable.read.allowed` (rather than `allowed_for_own`) permission to be able to query receivables created by other users.

            IDs of deleted users will still produce results here if those users had associated receivables. Valid but nonexistent user IDs do not raise errors but produce no results.

        sort : typing.Optional[ReceivableCursorFields]
            The field to sort the results by. Typically used together with the `order` parameter.

        tag_ids_in : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only receivables whose [tags](https://docs.monite.com/common/tags) include at least one of the tags with the specified IDs.

            For example, given receivables with the following tags:
            1. tagA
            2. tagB
            3. tagA, tagB
            4. tagC
            5. tagB, tagC


            `tag_ids__in=<tagA>&tag_ids__in=<tagB>` will return receivables 1, 2, 3, and 5.

            Valid but nonexistent tag IDs do not raise errors but produce no results.

        tag_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only receivables whose [tags](https://docs.monite.com/common/tags) include all of the tags with the specified IDs and optionally other tags that are not specified.

            For example, given receivables with the following tags:
            1. tagA
            2. tagB
            3. tagA, tagB
            4. tagC
            5. tagA, tagB, tagC


            `tag_ids=<tagA>&tag_ids=<tagB>` will return receivables 3 and 5.

        product_ids_in : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only receivables whose line items include at least one of the product IDs with the specified IDs.

            To specify multiple product IDs, repeat this parameter for each ID:
            `product_ids__in=<product1>&product_ids__in=<product2>`

            For example, given receivables with the following product IDs:
            1. productA
            2. productB
            3. productA, productB
            4. productC
            5. productB, productC


            `product_ids__in=<productA>&product_ids__in=<productB>` will return receivables 1, 2, 3, and 5.Valid but nonexistent product IDs do not raise errors but produce no results.

        product_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only receivables whose line items include all of the product IDs with the specified IDs and optionally other products that are not specified.

            To specify multiple product IDs, repeat this parameter for each ID:
            `product_ids=<product1>&product_ids=<product2>`

            For example, given receivables with the following product IDs:
            1. productA
            2. productB
            3. productA, productB
            4. productC
            5. productA, productB, productC


            `product_ids=<productA>&product_ids=<productB>` will return receivables 3 and 5.

        project_id_in : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only receivables whose `project_id` include at least one of the project_id with the specified IDs. Valid but nonexistent project IDs do not raise errors but produce no results.

        type : typing.Optional[ReceivableType]
            Return only receivables of the specified type. Use this parameter to get only invoices, or only quotes, or only credit notes.

        document_id : typing.Optional[str]
            Return a receivable with the exact specified document number (case-sensitive). The `document_id` is the user-facing document number such as INV-00042, not to be confused with Monite resource IDs (`id`).

        document_id_contains : typing.Optional[str]
            Return only receivables whose document number (`document_id`) contains the specified string (case-sensitive).

        document_id_icontains : typing.Optional[str]
            Return only receivables whose document number (`document_id`) contains the specified string (case-insensitive).

        issue_date_gt : typing.Optional[dt.datetime]
            Return only non-draft receivables that were issued after the specified date and time. The value must be in the ISO 8601 format `YYYY-MM-DDThh:mm[:ss[.ffffff]][Z|±hh:mm]`.

        issue_date_lt : typing.Optional[dt.datetime]
            Return only non-draft receivables that were issued before the specified date and time.

        issue_date_gte : typing.Optional[dt.datetime]
            Return only non-draft receivables that were issued on or after the specified date and time.

        issue_date_lte : typing.Optional[dt.datetime]
            Return only non-draft receivables that were issued before or on the specified date and time.

        created_at_gt : typing.Optional[dt.datetime]
            Return only receivables created after the specified date and time. The value must be in the ISO 8601 format `YYYY-MM-DDThh:mm[:ss[.ffffff]][Z|±hh:mm]`.

        created_at_lt : typing.Optional[dt.datetime]
            Return only receivables created before the specified date and time.

        created_at_gte : typing.Optional[dt.datetime]
            Return only receivables created on or after the specified date and time.

        created_at_lte : typing.Optional[dt.datetime]
            Return only receivables created before or on the specified date and time.

        counterpart_id : typing.Optional[str]
            Return only receivables created for the counterpart with the specified ID.

            Counterparts that have been deleted but have associated receivables will still return results here because the receivables contain a frozen copy of the counterpart data.

            If the specified counterpart ID does not exist and never existed, no results are returned.

        counterpart_name : typing.Optional[str]
            Return only receivables created for counterparts with the specified name (exact match, case-sensitive). For counterparts of `type` = `individual`, the full name is formatted as `first_name last_name`.

        counterpart_name_contains : typing.Optional[str]
            Return only receivables created for counterparts whose name contains the specified string (case-sensitive).

        counterpart_name_icontains : typing.Optional[str]
            Return only receivables created for counterparts whose name contains the specified string (case-insensitive).

        total_amount : typing.Optional[int]
            Return only receivables with the exact specified total amount. The amount must be specified in the [minor units](https://docs.monite.com/references/currencies#minor-units) of currency. For example, $12.5 is represented as 1250."

        total_amount_gt : typing.Optional[int]
            Return only receivables whose total amount (in minor units) exceeds the specified value.

        total_amount_lt : typing.Optional[int]
            Return only receivables whose total amount (in minor units) is less than the specified value.

        total_amount_gte : typing.Optional[int]
            Return only receivables whose total amount (in minor units) is greater than or equal to the specified value.

        total_amount_lte : typing.Optional[int]
            Return only receivables whose total amount (in minor units) is less than or equal to the specified value.

        discounted_subtotal : typing.Optional[int]
            Return only receivables with the exact specified discounted subtotal. The amount must be specified in the [minor units](https://docs.monite.com/references/currencies#minor-units) of currency. For example, $12.5 is represented as 1250.

        discounted_subtotal_gt : typing.Optional[int]
            Return only receivables whose discounted subtotal (in minor units) is greater than the specified value.

        discounted_subtotal_lt : typing.Optional[int]
            Return only receivables whose discounted subtotal (in minor units) is less than the specified value.

        discounted_subtotal_gte : typing.Optional[int]
            Return only receivables whose discounted subtotal (in minor units) is greater than or equal to the specified value.

        discounted_subtotal_lte : typing.Optional[int]
            Return only receivables whose discounted subtotal (in minor units) is less than or equal to the specified value.

        status : typing.Optional[ReceivablesGetRequestStatus]
            Return only receivables that have the specified status. See the applicable [invoice statuses](https://docs.monite.com/accounts-receivable/invoices/index), [quote statuses](https://docs.monite.com/accounts-receivable/quotes/index), and [credit note statuses](https://docs.monite.com/accounts-receivable/credit-notes#credit-note-lifecycle).

            To query multiple statuses at once, use the `status__in` parameter instead.

        entity_user_id : typing.Optional[str]
            Return only receivables created by the entity users with the specified IDs. To specify multiple user IDs, repeat this parameter for each ID:
            `entity_user_id__in=<user1>&entity_user_id__in=<user2>`

            If the request is authenticated using an entity user token, this user must have the `receivable.read.allowed` (rather than `allowed_for_own`) permission to be able to query receivables created by other users.

            IDs of deleted users will still produce results here if those users had associated receivables. Valid but nonexistent user IDs do not raise errors but produce no results.

        based_on : typing.Optional[str]
            This parameter accepts a quote ID or an invoice ID.

             * Specify a quote ID to find invoices created from this quote.
             * Specify an invoice ID to find credit notes created for this invoice or find recurring invoices created from a base invoice.

            Valid but nonexistent IDs do not raise errors but produce no results.

        due_date_gt : typing.Optional[str]
            Return invoices that are due after the specified date (exclusive, `YYYY-MM-DD`).

            This filter excludes quotes, credit notes, and draft invoices.

        due_date_lt : typing.Optional[str]
            Return invoices that are due before the specified date (exclusive, `YYYY-MM-DD`).

            This filter excludes quotes, credit notes, and draft invoices.

        due_date_gte : typing.Optional[str]
            Return invoices that are due on or after the specified date (`YYYY-MM-DD`).

            This filter excludes quotes, credit notes, and draft invoices.

        due_date_lte : typing.Optional[str]
            Return invoices that are due before or on the specified date (`YYYY-MM-DD`).

            This filter excludes quotes, credit notes, and draft invoices.

        project_id : typing.Optional[str]
            Return only receivables assigned to the project with the specified ID. Valid but nonexistent project IDs do not raise errors but return no results.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReceivablePaginationResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "receivables",
            method="GET",
            params={
                "order": order,
                "limit": limit,
                "pagination_token": pagination_token,
                "id__in": id_in,
                "status__in": status_in,
                "entity_user_id__in": entity_user_id_in,
                "sort": sort,
                "tag_ids__in": tag_ids_in,
                "tag_ids": tag_ids,
                "product_ids__in": product_ids_in,
                "product_ids": product_ids,
                "project_id__in": project_id_in,
                "type": type,
                "document_id": document_id,
                "document_id__contains": document_id_contains,
                "document_id__icontains": document_id_icontains,
                "issue_date__gt": serialize_datetime(issue_date_gt) if issue_date_gt is not None else None,
                "issue_date__lt": serialize_datetime(issue_date_lt) if issue_date_lt is not None else None,
                "issue_date__gte": serialize_datetime(issue_date_gte) if issue_date_gte is not None else None,
                "issue_date__lte": serialize_datetime(issue_date_lte) if issue_date_lte is not None else None,
                "created_at__gt": serialize_datetime(created_at_gt) if created_at_gt is not None else None,
                "created_at__lt": serialize_datetime(created_at_lt) if created_at_lt is not None else None,
                "created_at__gte": serialize_datetime(created_at_gte) if created_at_gte is not None else None,
                "created_at__lte": serialize_datetime(created_at_lte) if created_at_lte is not None else None,
                "counterpart_id": counterpart_id,
                "counterpart_name": counterpart_name,
                "counterpart_name__contains": counterpart_name_contains,
                "counterpart_name__icontains": counterpart_name_icontains,
                "total_amount": total_amount,
                "total_amount__gt": total_amount_gt,
                "total_amount__lt": total_amount_lt,
                "total_amount__gte": total_amount_gte,
                "total_amount__lte": total_amount_lte,
                "discounted_subtotal": discounted_subtotal,
                "discounted_subtotal__gt": discounted_subtotal_gt,
                "discounted_subtotal__lt": discounted_subtotal_lt,
                "discounted_subtotal__gte": discounted_subtotal_gte,
                "discounted_subtotal__lte": discounted_subtotal_lte,
                "status": status,
                "entity_user_id": entity_user_id,
                "based_on": based_on,
                "due_date__gt": due_date_gt,
                "due_date__lt": due_date_lt,
                "due_date__gte": due_date_gte,
                "due_date__lte": due_date_lte,
                "project_id": project_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivablePaginationResponse,
                    parse_obj_as(
                        type_=ReceivablePaginationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create(
        self, *, request: ReceivableFacadeCreatePayload, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ReceivableResponse]:
        """
        Parameters
        ----------
        request : ReceivableFacadeCreatePayload

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReceivableResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "receivables",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=ReceivableFacadeCreatePayload, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableResponse,
                    parse_obj_as(
                        type_=ReceivableResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_receivables_required_fields(
        self,
        *,
        counterpart_id: typing.Optional[str] = None,
        counterpart_billing_address_id: typing.Optional[str] = None,
        counterpart_country: typing.Optional[AllowedCountries] = None,
        counterpart_type: typing.Optional[CounterpartType] = None,
        entity_vat_id_id: typing.Optional[str] = None,
        counterpart_vat_id_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ReceivableRequiredFields]:
        """
        Get field requirements for invoice creation given the entity and counterpart details.

        Parameters
        ----------
        counterpart_id : typing.Optional[str]

        counterpart_billing_address_id : typing.Optional[str]

        counterpart_country : typing.Optional[AllowedCountries]

        counterpart_type : typing.Optional[CounterpartType]

        entity_vat_id_id : typing.Optional[str]

        counterpart_vat_id_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReceivableRequiredFields]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "receivables/required_fields",
            method="GET",
            params={
                "counterpart_id": counterpart_id,
                "counterpart_billing_address_id": counterpart_billing_address_id,
                "counterpart_country": counterpart_country,
                "counterpart_type": counterpart_type,
                "entity_vat_id_id": entity_vat_id_id,
                "counterpart_vat_id_id": counterpart_vat_id_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableRequiredFields,
                    parse_obj_as(
                        type_=ReceivableRequiredFields,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def post_receivables_search(
        self,
        *,
        based_on: typing.Optional[str] = OMIT,
        counterpart_id: typing.Optional[str] = OMIT,
        counterpart_name: typing.Optional[str] = OMIT,
        counterpart_name_contains: typing.Optional[str] = OMIT,
        counterpart_name_icontains: typing.Optional[str] = OMIT,
        created_at_gt: typing.Optional[dt.datetime] = OMIT,
        created_at_gte: typing.Optional[dt.datetime] = OMIT,
        created_at_lt: typing.Optional[dt.datetime] = OMIT,
        created_at_lte: typing.Optional[dt.datetime] = OMIT,
        discounted_subtotal: typing.Optional[int] = OMIT,
        discounted_subtotal_gt: typing.Optional[int] = OMIT,
        discounted_subtotal_gte: typing.Optional[int] = OMIT,
        discounted_subtotal_lt: typing.Optional[int] = OMIT,
        discounted_subtotal_lte: typing.Optional[int] = OMIT,
        document_id: typing.Optional[str] = OMIT,
        document_id_contains: typing.Optional[str] = OMIT,
        document_id_icontains: typing.Optional[str] = OMIT,
        due_date_gt: typing.Optional[str] = OMIT,
        due_date_gte: typing.Optional[str] = OMIT,
        due_date_lt: typing.Optional[str] = OMIT,
        due_date_lte: typing.Optional[str] = OMIT,
        entity_user_id: typing.Optional[str] = OMIT,
        entity_user_id_in: typing.Optional[typing.Sequence[str]] = OMIT,
        id_in: typing.Optional[typing.Sequence[str]] = OMIT,
        issue_date_gt: typing.Optional[dt.datetime] = OMIT,
        issue_date_gte: typing.Optional[dt.datetime] = OMIT,
        issue_date_lt: typing.Optional[dt.datetime] = OMIT,
        issue_date_lte: typing.Optional[dt.datetime] = OMIT,
        limit: typing.Optional[int] = OMIT,
        order: typing.Optional[OrderEnum] = OMIT,
        pagination_token: typing.Optional[str] = OMIT,
        product_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        product_ids_in: typing.Optional[typing.Sequence[str]] = OMIT,
        project_id: typing.Optional[str] = OMIT,
        project_id_in: typing.Optional[typing.Sequence[str]] = OMIT,
        sort: typing.Optional[ReceivableCursorFields2] = OMIT,
        status: typing.Optional[ReceivablesSearchRequestStatus] = OMIT,
        status_in: typing.Optional[typing.Sequence[str]] = OMIT,
        tag_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        tag_ids_in: typing.Optional[typing.Sequence[str]] = OMIT,
        total_amount: typing.Optional[int] = OMIT,
        total_amount_gt: typing.Optional[int] = OMIT,
        total_amount_gte: typing.Optional[int] = OMIT,
        total_amount_lt: typing.Optional[int] = OMIT,
        total_amount_lte: typing.Optional[int] = OMIT,
        type: typing.Optional[ReceivableType] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ReceivablePaginationResponse]:
        """
        This is a POST version of the `GET /receivables` endpoint. Use it to send search and filter parameters in the request body instead of the URL query string in case the query is too long and exceeds the URL length limit of your HTTP client.

        Parameters
        ----------
        based_on : typing.Optional[str]
            This parameter accepts a quote ID or an invoice ID.

            * Specify a quote ID to find invoices created from this quote.
            * Specify an invoice ID to find credit notes created for this invoice.

            Valid but nonexistent IDs do not raise errors but produce no results.

        counterpart_id : typing.Optional[str]
            Return only receivables created for the counterpart with the specified ID.

            Counterparts that have been deleted but have associated receivables will still return results here because the receivables contain a frozen copy of the counterpart data.

            If the specified counterpart ID does not exist and never existed, no results are returned.

        counterpart_name : typing.Optional[str]
            Return only receivables created for counterparts with the specified name (exact match, case-sensitive). For counterparts of `type` = `individual`, the full name is formatted as `first_name last_name`.

        counterpart_name_contains : typing.Optional[str]
            Return only receivables created for counterparts whose name contains the specified string (case-sensitive).

        counterpart_name_icontains : typing.Optional[str]
            Return only receivables created for counterparts whose name contains the specified string (case-insensitive).

        created_at_gt : typing.Optional[dt.datetime]
            Return only receivables created after the specified date and time. The value must be in the ISO 8601 format `YYYY-MM-DDThh:mm[:ss[.ffffff]][Z|±hh:mm]`.

        created_at_gte : typing.Optional[dt.datetime]
            Return only receivables created on or after the specified date and time.

        created_at_lt : typing.Optional[dt.datetime]
            Return only receivables created before the specified date and time.

        created_at_lte : typing.Optional[dt.datetime]
            Return only receivables created before or on the specified date and time.

        discounted_subtotal : typing.Optional[int]
            Return only receivables with the exact specified discounted subtotal. The amount must be specified in the [minor units](https://docs.monite.com/references/currencies#minor-units) of currency. For example, $12.5 is represented as 1250.

        discounted_subtotal_gt : typing.Optional[int]
            Return only receivables whose discounted subtotal (in minor units) is greater than the specified value.

        discounted_subtotal_gte : typing.Optional[int]
            Return only receivables whose discounted subtotal (in minor units) is greater than or equal to the specified value.

        discounted_subtotal_lt : typing.Optional[int]
            Return only receivables whose discounted subtotal (in minor units) is less than the specified value.

        discounted_subtotal_lte : typing.Optional[int]
            Return only receivables whose discounted subtotal (in minor units) is less than or equal to the specified value.

        document_id : typing.Optional[str]
            Return a receivable with the exact specified document number (case-sensitive). The `document_id` is the user-facing document number such as INV-00042, not to be confused with Monite resource IDs (`id`).

        document_id_contains : typing.Optional[str]
            Return only receivables whose document number (`document_id`) contains the specified string (case-sensitive).

        document_id_icontains : typing.Optional[str]
            Return only receivables whose document number (`document_id`) contains the specified string (case-insensitive).

        due_date_gt : typing.Optional[str]
            Return invoices that are due after the specified date (exclusive, `YYYY-MM-DD`).

            This filter excludes quotes, credit notes, and draft invoices.

        due_date_gte : typing.Optional[str]
            Return invoices that are due on or after the specified date (`YYYY-MM-DD`).

            This filter excludes quotes, credit notes, and draft invoices.

        due_date_lt : typing.Optional[str]
            Return invoices that are due before the specified date (exclusive, `YYYY-MM-DD`).

            This filter excludes quotes, credit notes, and draft invoices.

        due_date_lte : typing.Optional[str]
            Return invoices that are due before or on the specified date (`YYYY-MM-DD`).

            This filter excludes quotes, credit notes, and draft invoices.

        entity_user_id : typing.Optional[str]
            Return only receivables created by the entity user with the specified ID. To query receivables by multiple user IDs at once, use the `entity_user_id__in` parameter instead.

            If the request is authenticated using an entity user token, this user must have the `receivable.read.allowed` (rather than `allowed_for_own`) permission to be able to query receivables created by other users.

            IDs of deleted users will still produce results here if those users had associated receivables. Valid but nonexistent user IDs do not raise errors but produce no results.

        entity_user_id_in : typing.Optional[typing.Sequence[str]]
            Return only receivables created by the entity users with the specified IDs.

            If the request is authenticated using an entity user token, this user must have the `receivable.read.allowed` (rather than `allowed_for_own`) permission to be able to query receivables created by other users.

            IDs of deleted users will still produce results here if those users had associated receivables. Valid but nonexistent user IDs do not raise errors but produce no results.

        id_in : typing.Optional[typing.Sequence[str]]
            Return only receivables with the specified IDs. Valid but nonexistent IDs do not raise errors but produce no results.

        issue_date_gt : typing.Optional[dt.datetime]
            Return only non-draft receivables that were issued after the specified date and time. The value must be in the ISO 8601 format `YYYY-MM-DDThh:mm[:ss[.ffffff]][Z|±hh:mm]`.

        issue_date_gte : typing.Optional[dt.datetime]
            Return only non-draft receivables that were issued on or after the specified date and time.

        issue_date_lt : typing.Optional[dt.datetime]
            Return only non-draft receivables that were issued before the specified date and time.

        issue_date_lte : typing.Optional[dt.datetime]
            Return only non-draft receivables that were issued before or on the specified date and time.

        limit : typing.Optional[int]
            The number of items (0 .. 250) to return in a single page of the response. Default is 100. The response may contain fewer items if it is the last or only page.

            When using pagination with a non-default limit, you must provide the `limit` value alongside `pagination_token` in all subsequent pagination requests. Unlike other pagination parameters, `limit` is not inferred from `pagination_token`.

        order : typing.Optional[OrderEnum]
            Sort order (ascending by default). Typically used together with the `sort` parameter.

        pagination_token : typing.Optional[str]
            A pagination token obtained from a previous call to `GET /receivables` or `POST /receivables/search`. Use it to get the next or previous page of results for your initial query. If `pagination_token` is specified, all other parameters except `limit` are ignored and inferred from the initial query.

            If not specified, the first page of results will be returned.

        product_ids : typing.Optional[typing.Sequence[str]]
            Return only receivables with line items containing all of the products with the specified IDs and optionally other products that are not specified.

            For example, given receivables that contain the following products:

             1. productA
             2. productB
             3. productA, productB
             4. productC
             5. productA, productB, productC

            `product_ids` = `[productA, productB]` will return receivables 3 and 5.

            Valid but nonexistent product IDs do not raise errors but produce no results.

        product_ids_in : typing.Optional[typing.Sequence[str]]
            Return only receivables with line items containing at least one of the products with the specified IDs.

            For example, given receivables that contain the following products:

             1. productA
             2. productB
             3. productA, productB
             4. productC
             5. productB, productC

            `product_ids__in` = `[productA, productB]` will return receivables 1, 2, 3, and 5.

            Valid but nonexistent product IDs do not raise errors but produce no results.

        project_id : typing.Optional[str]
            Return only receivables assigned to the project with the specified ID. Valid but nonexistent project IDs do not raise errors but return no results.

        project_id_in : typing.Optional[typing.Sequence[str]]
            Return only receivables that belong to one of the projects with the specified IDs. Valid but nonexistent project IDs do not raise errors but produce no results.

        sort : typing.Optional[ReceivableCursorFields2]
            The field to sort the results by. Typically used together with the `order` parameter.

        status : typing.Optional[ReceivablesSearchRequestStatus]
            Return only receivables that have the specified status. See the applicable [invoice statuses](https://docs.monite.com/accounts-receivable/invoices/index), [quote statuses](https://docs.monite.com/accounts-receivable/quotes/index), and [credit note statuses](https://docs.monite.com/accounts-receivable/credit-notes#credit-note-lifecycle).

            To query multiple statuses at once, use the `status__in` parameter instead.

        status_in : typing.Optional[typing.Sequence[str]]
            Return only receivables that have the specified statuses. See the applicable [invoice statuses](https://docs.monite.com/accounts-receivable/invoices/index), [quote statuses](https://docs.monite.com/accounts-receivable/quotes/index), and [credit note statuses](https://docs.monite.com/accounts-receivable/credit-notes#credit-note-lifecycle).

        tag_ids : typing.Optional[typing.Sequence[str]]
            Return only receivables whose [tags](https://docs.monite.com/common/tags) include all of the tags with the specified IDs and optionally other tags that are not specified.

            For example, given receivables with the following tags:

             1. tagA
             2. tagB
             3. tagA, tagB
             4. tagC
             5. tagA, tagB, tagC

            `tag_ids` = `[tagA, tagB]` will return receivables 3 and 5.

        tag_ids_in : typing.Optional[typing.Sequence[str]]
            Return only receivables whose [tags](https://docs.monite.com/common/tags) include at least one of the tags with the specified IDs.

            For example, given receivables with the following tags:

             1. tagA
             2. tagB
             3. tagA, tagB
             4. tagC
             5. tagB, tagC

            `tag_ids__in` = `[tagA, tagB]` will return receivables 1, 2, 3, and 5.

            Valid but nonexistent tag IDs do not raise errors but produce no results.

        total_amount : typing.Optional[int]
            Return only receivables with the exact specified total amount. The amount must be specified in the [minor units](https://docs.monite.com/references/currencies#minor-units) of currency. For example, $12.5 is represented as 1250.

        total_amount_gt : typing.Optional[int]
            Return only receivables whose total amount (in minor units) exceeds the specified value.

        total_amount_gte : typing.Optional[int]
            Return only receivables whose total amount (in minor units) is greater than or equal to the specified value.

        total_amount_lt : typing.Optional[int]
            Return only receivables whose total amount (in minor units) is less than the specified value.

        total_amount_lte : typing.Optional[int]
            Return only receivables whose total amount (in minor units) is less than or equal to the specified value.

        type : typing.Optional[ReceivableType]
            Return only receivables of the specified type. Use this parameter to get only invoices, or only quotes, or only credit notes.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReceivablePaginationResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "receivables/search",
            method="POST",
            json={
                "based_on": based_on,
                "counterpart_id": counterpart_id,
                "counterpart_name": counterpart_name,
                "counterpart_name__contains": counterpart_name_contains,
                "counterpart_name__icontains": counterpart_name_icontains,
                "created_at__gt": created_at_gt,
                "created_at__gte": created_at_gte,
                "created_at__lt": created_at_lt,
                "created_at__lte": created_at_lte,
                "discounted_subtotal": discounted_subtotal,
                "discounted_subtotal__gt": discounted_subtotal_gt,
                "discounted_subtotal__gte": discounted_subtotal_gte,
                "discounted_subtotal__lt": discounted_subtotal_lt,
                "discounted_subtotal__lte": discounted_subtotal_lte,
                "document_id": document_id,
                "document_id__contains": document_id_contains,
                "document_id__icontains": document_id_icontains,
                "due_date__gt": due_date_gt,
                "due_date__gte": due_date_gte,
                "due_date__lt": due_date_lt,
                "due_date__lte": due_date_lte,
                "entity_user_id": entity_user_id,
                "entity_user_id__in": entity_user_id_in,
                "id__in": id_in,
                "issue_date__gt": issue_date_gt,
                "issue_date__gte": issue_date_gte,
                "issue_date__lt": issue_date_lt,
                "issue_date__lte": issue_date_lte,
                "limit": limit,
                "order": order,
                "pagination_token": pagination_token,
                "product_ids": product_ids,
                "product_ids__in": product_ids_in,
                "project_id": project_id,
                "project_id__in": project_id_in,
                "sort": sort,
                "status": status,
                "status__in": status_in,
                "tag_ids": tag_ids,
                "tag_ids__in": tag_ids_in,
                "total_amount": total_amount,
                "total_amount__gt": total_amount_gt,
                "total_amount__gte": total_amount_gte,
                "total_amount__lt": total_amount_lt,
                "total_amount__lte": total_amount_lte,
                "type": type,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivablePaginationResponse,
                    parse_obj_as(
                        type_=ReceivablePaginationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 406:
                raise NotAcceptableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_variables(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ReceivableTemplatesVariablesObjectList]:
        """
        Get a list of placeholders that can be used in email templates for customization.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReceivableTemplatesVariablesObjectList]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "receivables/variables",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableTemplatesVariablesObjectList,
                    parse_obj_as(
                        type_=ReceivableTemplatesVariablesObjectList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_by_id(
        self, receivable_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ReceivableResponse]:
        """
        Returns the details of an existing accounts receivable invoice, quote, or credit note with the specified ID.

        The response fields vary depending on the document type. Use the `type` field to distinguish between different document types.

        Entity users with the `receivable.read.allowed_for_own` permission (rather than `allowed`) can access only documents that they created themselves.

        Parameters
        ----------
        receivable_id : str
            ID of an existing invoice, quote, or credit note that you want to retrieve.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReceivableResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableResponse,
                    parse_obj_as(
                        type_=ReceivableResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_by_id(
        self, receivable_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        receivable_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_by_id(
        self,
        receivable_id: str,
        *,
        request: ReceivableUpdatePayload,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ReceivableResponse]:
        """
        Parameters
        ----------
        receivable_id : str

        request : ReceivableUpdatePayload

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReceivableResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}",
            method="PATCH",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=ReceivableUpdatePayload, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableResponse,
                    parse_obj_as(
                        type_=ReceivableResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def accept_by_id(
        self,
        receivable_id: str,
        *,
        signature: typing.Optional[Signature] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SuccessResult]:
        """
        Only quotes in the `issued` status can be accepted.

        When a quote is accepted, Monite automatically creates a draft invoice based on this quote. To find the newly created invoice, use `GET /receivables?based_on=QUOTE_ID`.

        Parameters
        ----------
        receivable_id : str

        signature : typing.Optional[Signature]
            The counterpart's signature. Required if the quote field `signature_required` is `true`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SuccessResult]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/accept",
            method="POST",
            json={
                "signature": convert_and_respect_annotation_metadata(
                    object_=signature, annotation=Signature, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SuccessResult,
                    parse_obj_as(
                        type_=SuccessResult,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def cancel_by_id(
        self, receivable_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        receivable_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/cancel",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def clone_by_id(
        self, receivable_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ReceivableResponse]:
        """
        Creates a copy of an existing accounts receivable invoice or quote. The original document can be in any status. The cloned document will have the `draft` status.

        Cloning a document requires that all of the referenced resource IDs (counterpart ID, product IDs, and others) still exist.

        Most of the original document's data is copied as is, with a few exceptions:

         * Some fields are not copied: `attachments`, `document_id`, `issue_date`, quote `expiry_date`.
         * Counterpart details, entity bank account details, and entity VAT number are fetched anew from their corresponding IDs.
           This means, for example, that if the counterpart details have been changed since the original invoice or quote was created,
           the cloned document will use the current counterpart details rather than the old details from the original document.

        Parameters
        ----------
        receivable_id : str
            ID of an existing invoice or quote that you want to clone.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReceivableResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/clone",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableResponse,
                    parse_obj_as(
                        type_=ReceivableResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def decline_by_id(
        self,
        receivable_id: str,
        *,
        comment: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SuccessResult]:
        """
        Only quotes in the `issued` status can be declined.

        Parameters
        ----------
        receivable_id : str

        comment : typing.Optional[str]
            Field with a comment on why the client declined this Quote

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SuccessResult]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/decline",
            method="POST",
            json={
                "comment": comment,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SuccessResult,
                    parse_obj_as(
                        type_=SuccessResult,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_history(
        self,
        receivable_id: str,
        *,
        order: typing.Optional[OrderEnum] = None,
        limit: typing.Optional[int] = None,
        pagination_token: typing.Optional[str] = None,
        sort: typing.Optional[ReceivableHistoryCursorFields] = None,
        event_type_in: typing.Optional[
            typing.Union[ReceivableHistoryEventTypeEnum, typing.Sequence[ReceivableHistoryEventTypeEnum]]
        ] = None,
        entity_user_id_in: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        timestamp_gt: typing.Optional[dt.datetime] = None,
        timestamp_lt: typing.Optional[dt.datetime] = None,
        timestamp_gte: typing.Optional[dt.datetime] = None,
        timestamp_lte: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ReceivableHistoryPaginationResponse]:
        """
        Returns the history of the specified accounts receivable document. The history contains all revisions of the document, status updates, and other events that occurred during the document's lifecycle. For more information, see [Document history](https://docs.monite.com/accounts-receivable/document-history).

        You can filter the history by the date range and event type. Events are sorted from oldest to newest by default.

        Parameters
        ----------
        receivable_id : str
            ID of the accounts receivable document whose history you want to get.

        order : typing.Optional[OrderEnum]
            Sort order (ascending by default). Typically used together with the `sort` parameter.

        limit : typing.Optional[int]
            The number of items (0 .. 100) to return in a single page of the response. The response may contain fewer items if it is the last or only page.

        pagination_token : typing.Optional[str]
            A pagination token obtained from a previous call to this endpoint. Use it to get the next or previous page of results for your initial query. If `pagination_token` is specified, all other query parameters are ignored and inferred from the initial query.

            If not specified, the first page of results will be returned.

        sort : typing.Optional[ReceivableHistoryCursorFields]
            The field to sort the results by. Typically used together with the `order` parameter.

        event_type_in : typing.Optional[typing.Union[ReceivableHistoryEventTypeEnum, typing.Sequence[ReceivableHistoryEventTypeEnum]]]
            Return only the specified [event types](https://docs.monite.com/accounts-receivable/document-history#event-types). To include multiple types, repeat this parameter for each value:
            `event_type__in=receivable_updated&event_type__in=status_changed`

        entity_user_id_in : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only events caused by the entity users with the specified IDs. To specify multiple user IDs, repeat this parameter for each ID:
            `entity_user_id__in=<user1>&entity_user_id__in=<user2>`

        timestamp_gt : typing.Optional[dt.datetime]
            Return only events that occurred after the specified date and time. The value must be in the ISO 8601 format `YYYY-MM-DDThh:mm[:ss[.ffffff]][Z|±hh:mm]`.

        timestamp_lt : typing.Optional[dt.datetime]
            Return only events that occurred before the specified date and time.

        timestamp_gte : typing.Optional[dt.datetime]
            Return only events that occurred on or after the specified date and time.

        timestamp_lte : typing.Optional[dt.datetime]
            Return only events that occurred before or on the specified date and time.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReceivableHistoryPaginationResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/history",
            method="GET",
            params={
                "order": order,
                "limit": limit,
                "pagination_token": pagination_token,
                "sort": sort,
                "event_type__in": event_type_in,
                "entity_user_id__in": entity_user_id_in,
                "timestamp__gt": serialize_datetime(timestamp_gt) if timestamp_gt is not None else None,
                "timestamp__lt": serialize_datetime(timestamp_lt) if timestamp_lt is not None else None,
                "timestamp__gte": serialize_datetime(timestamp_gte) if timestamp_gte is not None else None,
                "timestamp__lte": serialize_datetime(timestamp_lte) if timestamp_lte is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableHistoryPaginationResponse,
                    parse_obj_as(
                        type_=ReceivableHistoryPaginationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_history_by_id(
        self, receivable_history_id: str, receivable_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ReceivableHistoryResponse]:
        """
        Returns a single record from the change history of the specified accounts receivable document.

        Parameters
        ----------
        receivable_history_id : str
            ID of the history record to return. You can get these IDs from `GET /receivables/{receivable_id}/history`.

        receivable_id : str
            ID of the accounts receivable document whose history you want to get.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReceivableHistoryResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/history/{jsonable_encoder(receivable_history_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableHistoryResponse,
                    parse_obj_as(
                        type_=ReceivableHistoryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def issue_by_id(
        self, receivable_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ReceivableResponse]:
        """
        Parameters
        ----------
        receivable_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReceivableResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/issue",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableResponse,
                    parse_obj_as(
                        type_=ReceivableResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_line_items_by_id(
        self,
        receivable_id: str,
        *,
        data: typing.Sequence[LineItem],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[LineItemsResponse]:
        """
        Replace all line items of an existing invoice or quote with a new list of line items.

        Parameters
        ----------
        receivable_id : str

        data : typing.Sequence[LineItem]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[LineItemsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/line_items",
            method="PUT",
            json={
                "data": convert_and_respect_annotation_metadata(
                    object_=data, annotation=typing.Sequence[LineItem], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    LineItemsResponse,
                    parse_obj_as(
                        type_=LineItemsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_mails(
        self,
        receivable_id: str,
        *,
        order: typing.Optional[OrderEnum] = None,
        limit: typing.Optional[int] = None,
        pagination_token: typing.Optional[str] = None,
        sort: typing.Optional[ReceivableMailCursorFields] = None,
        status: typing.Optional[ReceivableMailStatusEnum] = None,
        status_in: typing.Optional[
            typing.Union[ReceivableMailStatusEnum, typing.Sequence[ReceivableMailStatusEnum]]
        ] = None,
        created_at_gt: typing.Optional[dt.datetime] = None,
        created_at_lt: typing.Optional[dt.datetime] = None,
        created_at_gte: typing.Optional[dt.datetime] = None,
        created_at_lte: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ReceivableMailPaginationResponse]:
        """
        Parameters
        ----------
        receivable_id : str

        order : typing.Optional[OrderEnum]
            Sort order (ascending by default). Typically used together with the `sort` parameter.

        limit : typing.Optional[int]
            The number of items (0 .. 100) to return in a single page of the response. The response may contain fewer items if it is the last or only page.

        pagination_token : typing.Optional[str]
            A pagination token obtained from a previous call to this endpoint. Use it to get the next or previous page of results for your initial query. If `pagination_token` is specified, all other query parameters are ignored and inferred from the initial query.

            If not specified, the first page of results will be returned.

        sort : typing.Optional[ReceivableMailCursorFields]
            The field to sort the results by. Typically used together with the `order` parameter.

        status : typing.Optional[ReceivableMailStatusEnum]

        status_in : typing.Optional[typing.Union[ReceivableMailStatusEnum, typing.Sequence[ReceivableMailStatusEnum]]]

        created_at_gt : typing.Optional[dt.datetime]

        created_at_lt : typing.Optional[dt.datetime]

        created_at_gte : typing.Optional[dt.datetime]

        created_at_lte : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReceivableMailPaginationResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/mails",
            method="GET",
            params={
                "order": order,
                "limit": limit,
                "pagination_token": pagination_token,
                "sort": sort,
                "status": status,
                "status__in": status_in,
                "created_at__gt": serialize_datetime(created_at_gt) if created_at_gt is not None else None,
                "created_at__lt": serialize_datetime(created_at_lt) if created_at_lt is not None else None,
                "created_at__gte": serialize_datetime(created_at_gte) if created_at_gte is not None else None,
                "created_at__lte": serialize_datetime(created_at_lte) if created_at_lte is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableMailPaginationResponse,
                    parse_obj_as(
                        type_=ReceivableMailPaginationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_mail_by_id(
        self, receivable_id: str, mail_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ReceivableMailResponse]:
        """
        Parameters
        ----------
        receivable_id : str

        mail_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReceivableMailResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/mails/{jsonable_encoder(mail_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableMailResponse,
                    parse_obj_as(
                        type_=ReceivableMailResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def mark_as_paid_by_id(
        self,
        receivable_id: str,
        *,
        comment: typing.Optional[str] = OMIT,
        paid_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ReceivableResponse]:
        """
        Parameters
        ----------
        receivable_id : str

        comment : typing.Optional[str]
            Optional comment explaining how the payment was made.

        paid_at : typing.Optional[dt.datetime]
            Date and time when the invoice was paid.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReceivableResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/mark_as_paid",
            method="POST",
            json={
                "comment": comment,
                "paid_at": paid_at,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableResponse,
                    parse_obj_as(
                        type_=ReceivableResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def mark_as_partially_paid_by_id(
        self,
        receivable_id: str,
        *,
        amount_paid: int,
        comment: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ReceivableResponse]:
        """
        Deprecated. Use `POST /payment_records` to record an invoice payment.

        Parameters
        ----------
        receivable_id : str

        amount_paid : int
            How much has been paid on the invoice (in minor units).

        comment : typing.Optional[str]
            Optional comment explaining how the payment was made.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReceivableResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/mark_as_partially_paid",
            method="POST",
            json={
                "amount_paid": amount_paid,
                "comment": comment,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableResponse,
                    parse_obj_as(
                        type_=ReceivableResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def mark_as_uncollectible_by_id(
        self,
        receivable_id: str,
        *,
        comment: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ReceivableResponse]:
        """
        Parameters
        ----------
        receivable_id : str

        comment : typing.Optional[str]
            Optional comment explains why the Invoice goes uncollectible.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReceivableResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/mark_as_uncollectible",
            method="POST",
            json={
                "comment": comment,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableResponse,
                    parse_obj_as(
                        type_=ReceivableResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_pdf_link_by_id(
        self, receivable_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ReceivableFileUrl]:
        """
        Parameters
        ----------
        receivable_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReceivableFileUrl]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/pdf_link",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableFileUrl,
                    parse_obj_as(
                        type_=ReceivableFileUrl,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def preview_by_id(
        self,
        receivable_id: str,
        *,
        body_text: str,
        subject_text: str,
        language: typing.Optional[LanguageCodeEnum] = OMIT,
        type: typing.Optional[ReceivablesPreviewTypeEnum] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ReceivablePreviewResponse]:
        """
        You can preview emails only for documents in the following statuses:

         * Invoices: `draft`, `issued`, `overdue`, `partially_paid`, `paid`.
           In the [non-compliant mode](https://docs.monite.com/accounts-receivable/regulatory-compliance/invoice-compliance): also `canceled`.
         * Quotes: `draft`, `issued`.
         * Credit notes: `draft`, `issued`.

        Parameters
        ----------
        receivable_id : str

        body_text : str
            Body text of the content

        subject_text : str
            Subject text of the content

        language : typing.Optional[LanguageCodeEnum]
            Language code for localization purposes

        type : typing.Optional[ReceivablesPreviewTypeEnum]
            The type of the preview document.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReceivablePreviewResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/preview",
            method="POST",
            json={
                "body_text": body_text,
                "language": language,
                "subject_text": subject_text,
                "type": type,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivablePreviewResponse,
                    parse_obj_as(
                        type_=ReceivablePreviewResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def send_by_id(
        self,
        receivable_id: str,
        *,
        body_text: str,
        subject_text: str,
        recipients: typing.Optional[Recipients] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ReceivableSendResponse]:
        """
        Only documents in the following statuses can be sent via email:

         * Invoices: `draft`, `issued`, `overdue`, `partially_paid`, `paid`.
           In the [non-compliant mode](https://docs.monite.com/accounts-receivable/regulatory-compliance/invoice-compliance): also `canceled`.
         * Quotes: `draft`, `issued`.
         * Credit notes: `draft`, `issued`.

        Draft documents are automatically moved to the `issued` status before sending.

        For more information, see [Send an invoice via email](https://docs.monite.com/accounts-receivable/invoices/create#send-via-email).

        Parameters
        ----------
        receivable_id : str

        body_text : str
            Body text of the content

        subject_text : str
            Subject text of the content

        recipients : typing.Optional[Recipients]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReceivableSendResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/send",
            method="POST",
            json={
                "body_text": body_text,
                "recipients": convert_and_respect_annotation_metadata(
                    object_=recipients, annotation=Recipients, direction="write"
                ),
                "subject_text": subject_text,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivableSendResponse,
                    parse_obj_as(
                        type_=ReceivableSendResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def send_test_reminder_by_id(
        self,
        receivable_id: str,
        *,
        reminder_type: ReminderTypeEnum,
        recipients: typing.Optional[Recipients] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ReceivablesSendResponse]:
        """
        Parameters
        ----------
        receivable_id : str

        reminder_type : ReminderTypeEnum
            The type of the reminder to be sent.

        recipients : typing.Optional[Recipients]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReceivablesSendResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/send_test_reminder",
            method="POST",
            json={
                "recipients": convert_and_respect_annotation_metadata(
                    object_=recipients, annotation=Recipients, direction="write"
                ),
                "reminder_type": reminder_type,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivablesSendResponse,
                    parse_obj_as(
                        type_=ReceivablesSendResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def verify_by_id(
        self, receivable_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ReceivablesVerifyResponse]:
        """
        Parameters
        ----------
        receivable_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReceivablesVerifyResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"receivables/{jsonable_encoder(receivable_id)}/verify",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReceivablesVerifyResponse,
                    parse_obj_as(
                        type_=ReceivablesVerifyResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
