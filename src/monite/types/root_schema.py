# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations
from ..core.pydantic_utilities import UniversalBaseModel
import typing
from .action_schema import ActionSchema
from ..core.pydantic_utilities import IS_PYDANTIC_V2
import pydantic
from .payable_action_schema import PayableActionSchema


class RootSchema_Person(UniversalBaseModel):
    object_type: typing.Literal["person"] = "person"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_Onboarding(UniversalBaseModel):
    object_type: typing.Literal["onboarding"] = "onboarding"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_Comment(UniversalBaseModel):
    object_type: typing.Literal["comment"] = "comment"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_Counterpart(UniversalBaseModel):
    object_type: typing.Literal["counterpart"] = "counterpart"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_EntityUser(UniversalBaseModel):
    object_type: typing.Literal["entity_user"] = "entity_user"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_Entity(UniversalBaseModel):
    object_type: typing.Literal["entity"] = "entity"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_EntityVatIds(UniversalBaseModel):
    object_type: typing.Literal["entity_vat_ids"] = "entity_vat_ids"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_CounterpartVatId(UniversalBaseModel):
    object_type: typing.Literal["counterpart_vat_id"] = "counterpart_vat_id"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_EntityBankAccount(UniversalBaseModel):
    object_type: typing.Literal["entity_bank_account"] = "entity_bank_account"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_Export(UniversalBaseModel):
    object_type: typing.Literal["export"] = "export"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_PayablesPurchaseOrder(UniversalBaseModel):
    object_type: typing.Literal["payables_purchase_order"] = "payables_purchase_order"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_PaymentReminder(UniversalBaseModel):
    object_type: typing.Literal["payment_reminder"] = "payment_reminder"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_OverdueReminder(UniversalBaseModel):
    object_type: typing.Literal["overdue_reminder"] = "overdue_reminder"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_Product(UniversalBaseModel):
    object_type: typing.Literal["product"] = "product"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_Project(UniversalBaseModel):
    object_type: typing.Literal["project"] = "project"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_Receivable(UniversalBaseModel):
    object_type: typing.Literal["receivable"] = "receivable"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_Reconciliation(UniversalBaseModel):
    object_type: typing.Literal["reconciliation"] = "reconciliation"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_Role(UniversalBaseModel):
    object_type: typing.Literal["role"] = "role"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_Tag(UniversalBaseModel):
    object_type: typing.Literal["tag"] = "tag"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_TodoTask(UniversalBaseModel):
    object_type: typing.Literal["todo_task"] = "todo_task"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_TodoTaskMute(UniversalBaseModel):
    object_type: typing.Literal["todo_task_mute"] = "todo_task_mute"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_Transaction(UniversalBaseModel):
    object_type: typing.Literal["transaction"] = "transaction"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_Workflow(UniversalBaseModel):
    object_type: typing.Literal["workflow"] = "workflow"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_ApprovalRequest(UniversalBaseModel):
    object_type: typing.Literal["approval_request"] = "approval_request"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_ApprovalPolicy(UniversalBaseModel):
    object_type: typing.Literal["approval_policy"] = "approval_policy"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_PaymentRecord(UniversalBaseModel):
    object_type: typing.Literal["payment_record"] = "payment_record"
    actions: typing.Optional[typing.List[ActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class RootSchema_Payable(UniversalBaseModel):
    object_type: typing.Literal["payable"] = "payable"
    actions: typing.Optional[typing.List[PayableActionSchema]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


RootSchema = typing.Union[
    RootSchema_Person,
    RootSchema_Onboarding,
    RootSchema_Comment,
    RootSchema_Counterpart,
    RootSchema_EntityUser,
    RootSchema_Entity,
    RootSchema_EntityVatIds,
    RootSchema_CounterpartVatId,
    RootSchema_EntityBankAccount,
    RootSchema_Export,
    RootSchema_PayablesPurchaseOrder,
    RootSchema_PaymentReminder,
    RootSchema_OverdueReminder,
    RootSchema_Product,
    RootSchema_Project,
    RootSchema_Receivable,
    RootSchema_Reconciliation,
    RootSchema_Role,
    RootSchema_Tag,
    RootSchema_TodoTask,
    RootSchema_TodoTaskMute,
    RootSchema_Transaction,
    RootSchema_Workflow,
    RootSchema_ApprovalRequest,
    RootSchema_ApprovalPolicy,
    RootSchema_PaymentRecord,
    RootSchema_Payable,
]
