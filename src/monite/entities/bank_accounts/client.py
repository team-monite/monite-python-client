# This file was auto-generated by Fern from our API Definition.

import typing
from ...core.client_wrapper import SyncClientWrapper
from ...core.request_options import RequestOptions
from ...types.entity_bank_account_pagination_response import EntityBankAccountPaginationResponse
from ...core.pydantic_utilities import parse_obj_as
from ...errors.conflict_error import ConflictError
from ...types.error_schema_response import ErrorSchemaResponse
from ...errors.unprocessable_entity_error import UnprocessableEntityError
from ...types.http_validation_error import HttpValidationError
from ...errors.internal_server_error import InternalServerError
from json.decoder import JSONDecodeError
from ...core.api_error import ApiError
from ...types.allowed_countries import AllowedCountries
from ...types.currency_enum import CurrencyEnum
from ...types.entity_bank_account_response import EntityBankAccountResponse
from ...types.complete_verification_airwallex_plaid_request import CompleteVerificationAirwallexPlaidRequest
from ...types.complete_verification_response import CompleteVerificationResponse
from ...core.serialization import convert_and_respect_annotation_metadata
from ...types.verification_airwallex_plaid_request import VerificationAirwallexPlaidRequest
from ...types.verification_response import VerificationResponse
from ...core.jsonable_encoder import jsonable_encoder
from ...errors.not_found_error import NotFoundError
from ...types.complete_refresh_verification_response import CompleteRefreshVerificationResponse
from ...types.bank_account_verifications import BankAccountVerifications
from ...core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class BankAccountsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get(self, *, request_options: typing.Optional[RequestOptions] = None) -> EntityBankAccountPaginationResponse:
        """
        Get all bank accounts of this entity.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EntityBankAccountPaginationResponse
            Successful Response

        Examples
        --------
        from monite import Monite

        client = Monite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )
        client.entities.bank_accounts.get()
        """
        _response = self._client_wrapper.httpx_client.request(
            "bank_accounts",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    EntityBankAccountPaginationResponse,
                    parse_obj_as(
                        type_=EntityBankAccountPaginationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self,
        *,
        country: AllowedCountries,
        currency: CurrencyEnum,
        account_holder_name: typing.Optional[str] = OMIT,
        account_number: typing.Optional[str] = OMIT,
        bank_name: typing.Optional[str] = OMIT,
        bic: typing.Optional[str] = OMIT,
        display_name: typing.Optional[str] = OMIT,
        iban: typing.Optional[str] = OMIT,
        is_default_for_currency: typing.Optional[bool] = OMIT,
        routing_number: typing.Optional[str] = OMIT,
        sort_code: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> EntityBankAccountResponse:
        """
        Add a new bank account for the specified entity.

        The minimum required fields are `currency` and `country`. Other required fields depend on the currency:

        - EUR accounts require `iban`.
        - GBP accounts require `account_holder_name`, `account_number`, and `sort_code`.
        - USD accounts require `account_holder_name`, `account_number`, and `routing_number`.
        - Accounts in other currencies require one of:
          - `iban`
          - `account_number` and `sort_code`
          - `account_number` and `routing_number`

        Parameters
        ----------
        country : AllowedCountries
            The country in which the bank account is registered, repsesented as a two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).

        currency : CurrencyEnum
            The currency of the bank account, represented as a three-letter ISO [currency code](https://docs.monite.com/docs/currencies).

        account_holder_name : typing.Optional[str]
            The name of the person or business that owns this bank account. Required if the account currency is GBP or USD.

        account_number : typing.Optional[str]
            The bank account number. Required if the account currency is GBP or USD. UK account numbers typically contain 8 digits. US bank account numbers contain 9 to 12 digits.

        bank_name : typing.Optional[str]
            The bank name.

        bic : typing.Optional[str]
            The SWIFT/BIC code of the bank.

        display_name : typing.Optional[str]
            User-defined name of this bank account, such as 'Primary account' or 'Savings account'.

        iban : typing.Optional[str]
            The IBAN of the bank account. Required if the account currency is EUR.

        is_default_for_currency : typing.Optional[bool]
            If set to `true` or if this is the first bank account added for the given currency, this account becomes the default one for its currency.

        routing_number : typing.Optional[str]
            The bank's routing transit number (RTN). Required if the account currency is USD. US routing numbers consist of 9 digits.

        sort_code : typing.Optional[str]
            The bank's sort code. Required if the account currency is GBP.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EntityBankAccountResponse
            Successful Response

        Examples
        --------
        from monite import Monite

        client = Monite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )
        client.entities.bank_accounts.create(
            country="AF",
            currency="AED",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "bank_accounts",
            method="POST",
            json={
                "account_holder_name": account_holder_name,
                "account_number": account_number,
                "bank_name": bank_name,
                "bic": bic,
                "country": country,
                "currency": currency,
                "display_name": display_name,
                "iban": iban,
                "is_default_for_currency": is_default_for_currency,
                "routing_number": routing_number,
                "sort_code": sort_code,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    EntityBankAccountResponse,
                    parse_obj_as(
                        type_=EntityBankAccountResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def complete_verification(
        self,
        *,
        airwallex_plaid: CompleteVerificationAirwallexPlaidRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CompleteVerificationResponse:
        """
        Parameters
        ----------
        airwallex_plaid : CompleteVerificationAirwallexPlaidRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CompleteVerificationResponse
            Successful Response

        Examples
        --------
        from monite import (
            AirwallexMandate,
            AirwallexPlaidAccount,
            AirwallexPlaidInstitution,
            CompleteVerificationAirwallexPlaidRequest,
            Monite,
        )

        client = Monite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )
        client.entities.bank_accounts.complete_verification(
            airwallex_plaid=CompleteVerificationAirwallexPlaidRequest(
                account=AirwallexPlaidAccount(
                    id="id",
                    mask="mask",
                    name="name",
                ),
                institution=AirwallexPlaidInstitution(
                    id="id",
                    name="name",
                ),
                mandate=AirwallexMandate(
                    email="email",
                    signatory="signatory",
                ),
                public_token="public_token",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "bank_accounts/complete_verification",
            method="POST",
            json={
                "airwallex_plaid": convert_and_respect_annotation_metadata(
                    object_=airwallex_plaid, annotation=CompleteVerificationAirwallexPlaidRequest, direction="write"
                ),
                "type": "airwallex_plaid",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CompleteVerificationResponse,
                    parse_obj_as(
                        type_=CompleteVerificationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def start_verification(
        self,
        *,
        airwallex_plaid: VerificationAirwallexPlaidRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> VerificationResponse:
        """
        Start entity bank account verification. The flow depends on verification type.
        For airwallex_plaid it generates Plaid Link token to init the Plaid SDK.

        Parameters
        ----------
        airwallex_plaid : VerificationAirwallexPlaidRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        VerificationResponse
            Successful Response

        Examples
        --------
        from monite import Monite, VerificationAirwallexPlaidRequest

        client = Monite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )
        client.entities.bank_accounts.start_verification(
            airwallex_plaid=VerificationAirwallexPlaidRequest(
                client_name="client_name",
                redirect_url="redirect_url",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "bank_accounts/start_verification",
            method="POST",
            json={
                "airwallex_plaid": convert_and_respect_annotation_metadata(
                    object_=airwallex_plaid, annotation=VerificationAirwallexPlaidRequest, direction="write"
                ),
                "type": "airwallex_plaid",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    VerificationResponse,
                    parse_obj_as(
                        type_=VerificationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_by_id(
        self, bank_account_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> EntityBankAccountResponse:
        """
        Retrieve a bank account by its ID.

        Parameters
        ----------
        bank_account_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EntityBankAccountResponse
            Successful Response

        Examples
        --------
        from monite import Monite

        client = Monite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )
        client.entities.bank_accounts.get_by_id(
            bank_account_id="bank_account_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"bank_accounts/{jsonable_encoder(bank_account_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    EntityBankAccountResponse,
                    parse_obj_as(
                        type_=EntityBankAccountResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_by_id(self, bank_account_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Delete the bank account specified by its ID.

        Parameters
        ----------
        bank_account_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from monite import Monite

        client = Monite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )
        client.entities.bank_accounts.delete_by_id(
            bank_account_id="bank_account_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"bank_accounts/{jsonable_encoder(bank_account_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_by_id(
        self,
        bank_account_id: str,
        *,
        account_holder_name: typing.Optional[str] = OMIT,
        display_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> EntityBankAccountResponse:
        """
        Change the specified fields with the provided values.

        Parameters
        ----------
        bank_account_id : str

        account_holder_name : typing.Optional[str]
            The name of the person or business that owns this bank account. If the account currency is GBP or USD, the holder name cannot be changed to an empty string.

        display_name : typing.Optional[str]
            User-defined name of this bank account, such as 'Primary account' or 'Savings account'.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EntityBankAccountResponse
            Successful Response

        Examples
        --------
        from monite import Monite

        client = Monite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )
        client.entities.bank_accounts.update_by_id(
            bank_account_id="bank_account_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"bank_accounts/{jsonable_encoder(bank_account_id)}",
            method="PATCH",
            json={
                "account_holder_name": account_holder_name,
                "display_name": display_name,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    EntityBankAccountResponse,
                    parse_obj_as(
                        type_=EntityBankAccountResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def complete_verification_by_id(
        self, bank_account_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> CompleteRefreshVerificationResponse:
        """
        Parameters
        ----------
        bank_account_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CompleteRefreshVerificationResponse
            Successful Response

        Examples
        --------
        from monite import Monite

        client = Monite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )
        client.entities.bank_accounts.complete_verification_by_id(
            bank_account_id="bank_account_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"bank_accounts/{jsonable_encoder(bank_account_id)}/complete_verification",
            method="POST",
            json={
                "type": "airwallex_plaid",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CompleteRefreshVerificationResponse,
                    parse_obj_as(
                        type_=CompleteRefreshVerificationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def make_default_by_id(
        self, bank_account_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> EntityBankAccountResponse:
        """
        Set a bank account as the default for this entity per currency.

        Parameters
        ----------
        bank_account_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EntityBankAccountResponse
            Successful Response

        Examples
        --------
        from monite import Monite

        client = Monite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )
        client.entities.bank_accounts.make_default_by_id(
            bank_account_id="bank_account_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"bank_accounts/{jsonable_encoder(bank_account_id)}/make_default",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    EntityBankAccountResponse,
                    parse_obj_as(
                        type_=EntityBankAccountResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def refresh_verification_by_id(
        self,
        bank_account_id: str,
        *,
        airwallex_plaid: VerificationAirwallexPlaidRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> VerificationResponse:
        """
        Parameters
        ----------
        bank_account_id : str

        airwallex_plaid : VerificationAirwallexPlaidRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        VerificationResponse
            Successful Response

        Examples
        --------
        from monite import Monite, VerificationAirwallexPlaidRequest

        client = Monite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )
        client.entities.bank_accounts.refresh_verification_by_id(
            bank_account_id="bank_account_id",
            airwallex_plaid=VerificationAirwallexPlaidRequest(
                client_name="client_name",
                redirect_url="redirect_url",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"bank_accounts/{jsonable_encoder(bank_account_id)}/refresh_verification",
            method="POST",
            json={
                "airwallex_plaid": convert_and_respect_annotation_metadata(
                    object_=airwallex_plaid, annotation=VerificationAirwallexPlaidRequest, direction="write"
                ),
                "type": "airwallex_plaid",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    VerificationResponse,
                    parse_obj_as(
                        type_=VerificationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_verifications_by_id(
        self, bank_account_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> BankAccountVerifications:
        """
        Parameters
        ----------
        bank_account_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BankAccountVerifications
            Successful Response

        Examples
        --------
        from monite import Monite

        client = Monite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )
        client.entities.bank_accounts.get_verifications_by_id(
            bank_account_id="bank_account_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"bank_accounts/{jsonable_encoder(bank_account_id)}/verifications",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BankAccountVerifications,
                    parse_obj_as(
                        type_=BankAccountVerifications,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncBankAccountsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> EntityBankAccountPaginationResponse:
        """
        Get all bank accounts of this entity.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EntityBankAccountPaginationResponse
            Successful Response

        Examples
        --------
        import asyncio

        from monite import AsyncMonite

        client = AsyncMonite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.entities.bank_accounts.get()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "bank_accounts",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    EntityBankAccountPaginationResponse,
                    parse_obj_as(
                        type_=EntityBankAccountPaginationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self,
        *,
        country: AllowedCountries,
        currency: CurrencyEnum,
        account_holder_name: typing.Optional[str] = OMIT,
        account_number: typing.Optional[str] = OMIT,
        bank_name: typing.Optional[str] = OMIT,
        bic: typing.Optional[str] = OMIT,
        display_name: typing.Optional[str] = OMIT,
        iban: typing.Optional[str] = OMIT,
        is_default_for_currency: typing.Optional[bool] = OMIT,
        routing_number: typing.Optional[str] = OMIT,
        sort_code: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> EntityBankAccountResponse:
        """
        Add a new bank account for the specified entity.

        The minimum required fields are `currency` and `country`. Other required fields depend on the currency:

        - EUR accounts require `iban`.
        - GBP accounts require `account_holder_name`, `account_number`, and `sort_code`.
        - USD accounts require `account_holder_name`, `account_number`, and `routing_number`.
        - Accounts in other currencies require one of:
          - `iban`
          - `account_number` and `sort_code`
          - `account_number` and `routing_number`

        Parameters
        ----------
        country : AllowedCountries
            The country in which the bank account is registered, repsesented as a two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).

        currency : CurrencyEnum
            The currency of the bank account, represented as a three-letter ISO [currency code](https://docs.monite.com/docs/currencies).

        account_holder_name : typing.Optional[str]
            The name of the person or business that owns this bank account. Required if the account currency is GBP or USD.

        account_number : typing.Optional[str]
            The bank account number. Required if the account currency is GBP or USD. UK account numbers typically contain 8 digits. US bank account numbers contain 9 to 12 digits.

        bank_name : typing.Optional[str]
            The bank name.

        bic : typing.Optional[str]
            The SWIFT/BIC code of the bank.

        display_name : typing.Optional[str]
            User-defined name of this bank account, such as 'Primary account' or 'Savings account'.

        iban : typing.Optional[str]
            The IBAN of the bank account. Required if the account currency is EUR.

        is_default_for_currency : typing.Optional[bool]
            If set to `true` or if this is the first bank account added for the given currency, this account becomes the default one for its currency.

        routing_number : typing.Optional[str]
            The bank's routing transit number (RTN). Required if the account currency is USD. US routing numbers consist of 9 digits.

        sort_code : typing.Optional[str]
            The bank's sort code. Required if the account currency is GBP.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EntityBankAccountResponse
            Successful Response

        Examples
        --------
        import asyncio

        from monite import AsyncMonite

        client = AsyncMonite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.entities.bank_accounts.create(
                country="AF",
                currency="AED",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "bank_accounts",
            method="POST",
            json={
                "account_holder_name": account_holder_name,
                "account_number": account_number,
                "bank_name": bank_name,
                "bic": bic,
                "country": country,
                "currency": currency,
                "display_name": display_name,
                "iban": iban,
                "is_default_for_currency": is_default_for_currency,
                "routing_number": routing_number,
                "sort_code": sort_code,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    EntityBankAccountResponse,
                    parse_obj_as(
                        type_=EntityBankAccountResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def complete_verification(
        self,
        *,
        airwallex_plaid: CompleteVerificationAirwallexPlaidRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CompleteVerificationResponse:
        """
        Parameters
        ----------
        airwallex_plaid : CompleteVerificationAirwallexPlaidRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CompleteVerificationResponse
            Successful Response

        Examples
        --------
        import asyncio

        from monite import (
            AirwallexMandate,
            AirwallexPlaidAccount,
            AirwallexPlaidInstitution,
            AsyncMonite,
            CompleteVerificationAirwallexPlaidRequest,
        )

        client = AsyncMonite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.entities.bank_accounts.complete_verification(
                airwallex_plaid=CompleteVerificationAirwallexPlaidRequest(
                    account=AirwallexPlaidAccount(
                        id="id",
                        mask="mask",
                        name="name",
                    ),
                    institution=AirwallexPlaidInstitution(
                        id="id",
                        name="name",
                    ),
                    mandate=AirwallexMandate(
                        email="email",
                        signatory="signatory",
                    ),
                    public_token="public_token",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "bank_accounts/complete_verification",
            method="POST",
            json={
                "airwallex_plaid": convert_and_respect_annotation_metadata(
                    object_=airwallex_plaid, annotation=CompleteVerificationAirwallexPlaidRequest, direction="write"
                ),
                "type": "airwallex_plaid",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CompleteVerificationResponse,
                    parse_obj_as(
                        type_=CompleteVerificationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def start_verification(
        self,
        *,
        airwallex_plaid: VerificationAirwallexPlaidRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> VerificationResponse:
        """
        Start entity bank account verification. The flow depends on verification type.
        For airwallex_plaid it generates Plaid Link token to init the Plaid SDK.

        Parameters
        ----------
        airwallex_plaid : VerificationAirwallexPlaidRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        VerificationResponse
            Successful Response

        Examples
        --------
        import asyncio

        from monite import AsyncMonite, VerificationAirwallexPlaidRequest

        client = AsyncMonite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.entities.bank_accounts.start_verification(
                airwallex_plaid=VerificationAirwallexPlaidRequest(
                    client_name="client_name",
                    redirect_url="redirect_url",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "bank_accounts/start_verification",
            method="POST",
            json={
                "airwallex_plaid": convert_and_respect_annotation_metadata(
                    object_=airwallex_plaid, annotation=VerificationAirwallexPlaidRequest, direction="write"
                ),
                "type": "airwallex_plaid",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    VerificationResponse,
                    parse_obj_as(
                        type_=VerificationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_by_id(
        self, bank_account_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> EntityBankAccountResponse:
        """
        Retrieve a bank account by its ID.

        Parameters
        ----------
        bank_account_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EntityBankAccountResponse
            Successful Response

        Examples
        --------
        import asyncio

        from monite import AsyncMonite

        client = AsyncMonite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.entities.bank_accounts.get_by_id(
                bank_account_id="bank_account_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"bank_accounts/{jsonable_encoder(bank_account_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    EntityBankAccountResponse,
                    parse_obj_as(
                        type_=EntityBankAccountResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_by_id(
        self, bank_account_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Delete the bank account specified by its ID.

        Parameters
        ----------
        bank_account_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from monite import AsyncMonite

        client = AsyncMonite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.entities.bank_accounts.delete_by_id(
                bank_account_id="bank_account_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"bank_accounts/{jsonable_encoder(bank_account_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_by_id(
        self,
        bank_account_id: str,
        *,
        account_holder_name: typing.Optional[str] = OMIT,
        display_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> EntityBankAccountResponse:
        """
        Change the specified fields with the provided values.

        Parameters
        ----------
        bank_account_id : str

        account_holder_name : typing.Optional[str]
            The name of the person or business that owns this bank account. If the account currency is GBP or USD, the holder name cannot be changed to an empty string.

        display_name : typing.Optional[str]
            User-defined name of this bank account, such as 'Primary account' or 'Savings account'.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EntityBankAccountResponse
            Successful Response

        Examples
        --------
        import asyncio

        from monite import AsyncMonite

        client = AsyncMonite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.entities.bank_accounts.update_by_id(
                bank_account_id="bank_account_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"bank_accounts/{jsonable_encoder(bank_account_id)}",
            method="PATCH",
            json={
                "account_holder_name": account_holder_name,
                "display_name": display_name,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    EntityBankAccountResponse,
                    parse_obj_as(
                        type_=EntityBankAccountResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def complete_verification_by_id(
        self, bank_account_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> CompleteRefreshVerificationResponse:
        """
        Parameters
        ----------
        bank_account_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CompleteRefreshVerificationResponse
            Successful Response

        Examples
        --------
        import asyncio

        from monite import AsyncMonite

        client = AsyncMonite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.entities.bank_accounts.complete_verification_by_id(
                bank_account_id="bank_account_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"bank_accounts/{jsonable_encoder(bank_account_id)}/complete_verification",
            method="POST",
            json={
                "type": "airwallex_plaid",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CompleteRefreshVerificationResponse,
                    parse_obj_as(
                        type_=CompleteRefreshVerificationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def make_default_by_id(
        self, bank_account_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> EntityBankAccountResponse:
        """
        Set a bank account as the default for this entity per currency.

        Parameters
        ----------
        bank_account_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EntityBankAccountResponse
            Successful Response

        Examples
        --------
        import asyncio

        from monite import AsyncMonite

        client = AsyncMonite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.entities.bank_accounts.make_default_by_id(
                bank_account_id="bank_account_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"bank_accounts/{jsonable_encoder(bank_account_id)}/make_default",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    EntityBankAccountResponse,
                    parse_obj_as(
                        type_=EntityBankAccountResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def refresh_verification_by_id(
        self,
        bank_account_id: str,
        *,
        airwallex_plaid: VerificationAirwallexPlaidRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> VerificationResponse:
        """
        Parameters
        ----------
        bank_account_id : str

        airwallex_plaid : VerificationAirwallexPlaidRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        VerificationResponse
            Successful Response

        Examples
        --------
        import asyncio

        from monite import AsyncMonite, VerificationAirwallexPlaidRequest

        client = AsyncMonite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.entities.bank_accounts.refresh_verification_by_id(
                bank_account_id="bank_account_id",
                airwallex_plaid=VerificationAirwallexPlaidRequest(
                    client_name="client_name",
                    redirect_url="redirect_url",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"bank_accounts/{jsonable_encoder(bank_account_id)}/refresh_verification",
            method="POST",
            json={
                "airwallex_plaid": convert_and_respect_annotation_metadata(
                    object_=airwallex_plaid, annotation=VerificationAirwallexPlaidRequest, direction="write"
                ),
                "type": "airwallex_plaid",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    VerificationResponse,
                    parse_obj_as(
                        type_=VerificationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_verifications_by_id(
        self, bank_account_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> BankAccountVerifications:
        """
        Parameters
        ----------
        bank_account_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BankAccountVerifications
            Successful Response

        Examples
        --------
        import asyncio

        from monite import AsyncMonite

        client = AsyncMonite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.entities.bank_accounts.get_verifications_by_id(
                bank_account_id="bank_account_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"bank_accounts/{jsonable_encoder(bank_account_id)}/verifications",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BankAccountVerifications,
                    parse_obj_as(
                        type_=BankAccountVerifications,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        ErrorSchemaResponse,
                        parse_obj_as(
                            type_=ErrorSchemaResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
