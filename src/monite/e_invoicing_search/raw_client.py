# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..errors.too_many_requests_error import TooManyRequestsError
from ..errors.unauthorized_error import UnauthorizedError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.counterpart_einvoicing_credential_existence_response import (
    CounterpartEinvoicingCredentialExistenceResponse,
)
from ..types.einvoice_schema_type_enum import EinvoiceSchemaTypeEnum


class RawEInvoicingSearchClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_einvoice_search(
        self,
        *,
        network_identifier: str,
        network_schema: EinvoiceSchemaTypeEnum,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CounterpartEinvoicingCredentialExistenceResponse]:
        """
        Checks if the specified VAT number or business number is registered on the PEPPOL network as a receiver. For example, you can use this endpoint to check if an entity's counterparts are registered in PEPPOL before creating e-invoices for those counterparts.

        The lookup is powered by PEPPOL SMPs (Service Metadata Publishers) so it also includes registrations that are not visible in the public PEPPOL directory.

        Both partner tokens and entity user tokens can be used for authentication.

        Production and sandbox lookups are separate.

        Parameters
        ----------
        network_identifier : str
            VAT number or business number, depending on the `network_schema` used. VAT numbers must include the country prefix, for example, use `DE010101010` not `10101010`.

            **Note:** This endpoint does not validate the format of VAT numbers and business numbers (such as the length or characters used). Invalid values will return `{"exists": false}`.

        network_schema : EinvoiceSchemaTypeEnum
            [PEPPOL scheme](https://docs.monite.com/e-invoicing/peppol-ids#schemes) name.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CounterpartEinvoicingCredentialExistenceResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "einvoice_search",
            method="GET",
            params={
                "network_identifier": network_identifier,
                "network_schema": network_schema,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CounterpartEinvoicingCredentialExistenceResponse,
                    parse_obj_as(
                        type_=CounterpartEinvoicingCredentialExistenceResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawEInvoicingSearchClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_einvoice_search(
        self,
        *,
        network_identifier: str,
        network_schema: EinvoiceSchemaTypeEnum,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CounterpartEinvoicingCredentialExistenceResponse]:
        """
        Checks if the specified VAT number or business number is registered on the PEPPOL network as a receiver. For example, you can use this endpoint to check if an entity's counterparts are registered in PEPPOL before creating e-invoices for those counterparts.

        The lookup is powered by PEPPOL SMPs (Service Metadata Publishers) so it also includes registrations that are not visible in the public PEPPOL directory.

        Both partner tokens and entity user tokens can be used for authentication.

        Production and sandbox lookups are separate.

        Parameters
        ----------
        network_identifier : str
            VAT number or business number, depending on the `network_schema` used. VAT numbers must include the country prefix, for example, use `DE010101010` not `10101010`.

            **Note:** This endpoint does not validate the format of VAT numbers and business numbers (such as the length or characters used). Invalid values will return `{"exists": false}`.

        network_schema : EinvoiceSchemaTypeEnum
            [PEPPOL scheme](https://docs.monite.com/e-invoicing/peppol-ids#schemes) name.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CounterpartEinvoicingCredentialExistenceResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "einvoice_search",
            method="GET",
            params={
                "network_identifier": network_identifier,
                "network_schema": network_schema,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CounterpartEinvoicingCredentialExistenceResponse,
                    parse_obj_as(
                        type_=CounterpartEinvoicingCredentialExistenceResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
