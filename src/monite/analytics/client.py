# This file was auto-generated by Fern from our API Definition.

from ..core.client_wrapper import SyncClientWrapper
from ..types.credit_note_metric_enum import CreditNoteMetricEnum
from ..types.aggregation_function_enum import AggregationFunctionEnum
import typing
from ..types.credit_note_dimension_enum import CreditNoteDimensionEnum
from ..types.date_dimension_breakdown_enum import DateDimensionBreakdownEnum
import datetime as dt
from ..types.credit_note_state_enum import CreditNoteStateEnum
from ..types.currency_enum import CurrencyEnum
from ..core.request_options import RequestOptions
from ..types.payable_analytics_response import PayableAnalyticsResponse
from ..core.datetime_utils import serialize_datetime
from ..core.pydantic_utilities import parse_obj_as
from ..errors.unauthorized_error import UnauthorizedError
from ..errors.forbidden_error import ForbiddenError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.http_validation_error import HttpValidationError
from ..errors.internal_server_error import InternalServerError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from ..types.payable_metric_enum import PayableMetricEnum
from ..types.payable_dimension_enum import PayableDimensionEnum
from ..types.payable_state_enum import PayableStateEnum
from ..types.source_of_payable_data_enum import SourceOfPayableDataEnum
from ..types.ocr_status_enum import OcrStatusEnum
from ..core.client_wrapper import AsyncClientWrapper


class AnalyticsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_analytics_credit_notes(
        self,
        *,
        metric: CreditNoteMetricEnum,
        aggregation_function: AggregationFunctionEnum,
        dimension: typing.Optional[CreditNoteDimensionEnum] = None,
        date_dimension_breakdown: typing.Optional[DateDimensionBreakdownEnum] = None,
        created_at_gt: typing.Optional[dt.datetime] = None,
        created_at_lt: typing.Optional[dt.datetime] = None,
        created_at_gte: typing.Optional[dt.datetime] = None,
        created_at_lte: typing.Optional[dt.datetime] = None,
        issued_at: typing.Optional[str] = None,
        issued_at_gt: typing.Optional[str] = None,
        issued_at_lt: typing.Optional[str] = None,
        issued_at_gte: typing.Optional[str] = None,
        issued_at_lte: typing.Optional[str] = None,
        document_id: typing.Optional[str] = None,
        document_id_iexact: typing.Optional[str] = None,
        document_id_contains: typing.Optional[str] = None,
        document_id_icontains: typing.Optional[str] = None,
        total_amount_gt: typing.Optional[int] = None,
        total_amount_lt: typing.Optional[int] = None,
        total_amount_gte: typing.Optional[int] = None,
        total_amount_lte: typing.Optional[int] = None,
        subtotal_gt: typing.Optional[int] = None,
        subtotal_lt: typing.Optional[int] = None,
        subtotal_gte: typing.Optional[int] = None,
        subtotal_lte: typing.Optional[int] = None,
        based_on: typing.Optional[str] = None,
        counterpart_id: typing.Optional[str] = None,
        created_by_entity_user_id: typing.Optional[str] = None,
        status: typing.Optional[CreditNoteStateEnum] = None,
        status_in: typing.Optional[typing.Union[CreditNoteStateEnum, typing.Sequence[CreditNoteStateEnum]]] = None,
        status_not_in: typing.Optional[typing.Union[CreditNoteStateEnum, typing.Sequence[CreditNoteStateEnum]]] = None,
        currency: typing.Optional[CurrencyEnum] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PayableAnalyticsResponse:
        """
        Retrieve aggregated statistics for payables with different breakdowns.

        Parameters
        ----------
        metric : CreditNoteMetricEnum

        aggregation_function : AggregationFunctionEnum

        dimension : typing.Optional[CreditNoteDimensionEnum]

        date_dimension_breakdown : typing.Optional[DateDimensionBreakdownEnum]

        created_at_gt : typing.Optional[dt.datetime]

        created_at_lt : typing.Optional[dt.datetime]

        created_at_gte : typing.Optional[dt.datetime]

        created_at_lte : typing.Optional[dt.datetime]

        issued_at : typing.Optional[str]

        issued_at_gt : typing.Optional[str]

        issued_at_lt : typing.Optional[str]

        issued_at_gte : typing.Optional[str]

        issued_at_lte : typing.Optional[str]

        document_id : typing.Optional[str]

        document_id_iexact : typing.Optional[str]

        document_id_contains : typing.Optional[str]

        document_id_icontains : typing.Optional[str]

        total_amount_gt : typing.Optional[int]

        total_amount_lt : typing.Optional[int]

        total_amount_gte : typing.Optional[int]

        total_amount_lte : typing.Optional[int]

        subtotal_gt : typing.Optional[int]

        subtotal_lt : typing.Optional[int]

        subtotal_gte : typing.Optional[int]

        subtotal_lte : typing.Optional[int]

        based_on : typing.Optional[str]

        counterpart_id : typing.Optional[str]

        created_by_entity_user_id : typing.Optional[str]

        status : typing.Optional[CreditNoteStateEnum]

        status_in : typing.Optional[typing.Union[CreditNoteStateEnum, typing.Sequence[CreditNoteStateEnum]]]

        status_not_in : typing.Optional[typing.Union[CreditNoteStateEnum, typing.Sequence[CreditNoteStateEnum]]]

        currency : typing.Optional[CurrencyEnum]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PayableAnalyticsResponse
            Successful Response

        Examples
        --------
        from monite import Monite

        client = Monite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )
        client.analytics.get_analytics_credit_notes(
            metric="id",
            aggregation_function="count",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "analytics/credit_notes",
            method="GET",
            params={
                "dimension": dimension,
                "metric": metric,
                "aggregation_function": aggregation_function,
                "date_dimension_breakdown": date_dimension_breakdown,
                "created_at__gt": serialize_datetime(created_at_gt) if created_at_gt is not None else None,
                "created_at__lt": serialize_datetime(created_at_lt) if created_at_lt is not None else None,
                "created_at__gte": serialize_datetime(created_at_gte) if created_at_gte is not None else None,
                "created_at__lte": serialize_datetime(created_at_lte) if created_at_lte is not None else None,
                "issued_at": issued_at,
                "issued_at__gt": issued_at_gt,
                "issued_at__lt": issued_at_lt,
                "issued_at__gte": issued_at_gte,
                "issued_at__lte": issued_at_lte,
                "document_id": document_id,
                "document_id__iexact": document_id_iexact,
                "document_id__contains": document_id_contains,
                "document_id__icontains": document_id_icontains,
                "total_amount__gt": total_amount_gt,
                "total_amount__lt": total_amount_lt,
                "total_amount__gte": total_amount_gte,
                "total_amount__lte": total_amount_lte,
                "subtotal__gt": subtotal_gt,
                "subtotal__lt": subtotal_lt,
                "subtotal__gte": subtotal_gte,
                "subtotal__lte": subtotal_lte,
                "based_on": based_on,
                "counterpart_id": counterpart_id,
                "created_by_entity_user_id": created_by_entity_user_id,
                "status": status,
                "status__in": status_in,
                "status__not_in": status_not_in,
                "currency": currency,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PayableAnalyticsResponse,
                    parse_obj_as(
                        type_=PayableAnalyticsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_analytics_payables(
        self,
        *,
        metric: PayableMetricEnum,
        aggregation_function: AggregationFunctionEnum,
        dimension: typing.Optional[PayableDimensionEnum] = None,
        date_dimension_breakdown: typing.Optional[DateDimensionBreakdownEnum] = None,
        created_at_gt: typing.Optional[dt.datetime] = None,
        created_at_lt: typing.Optional[dt.datetime] = None,
        created_at_gte: typing.Optional[dt.datetime] = None,
        created_at_lte: typing.Optional[dt.datetime] = None,
        status: typing.Optional[PayableStateEnum] = None,
        status_in: typing.Optional[typing.Union[PayableStateEnum, typing.Sequence[PayableStateEnum]]] = None,
        id_in: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        total_amount: typing.Optional[int] = None,
        total_amount_gt: typing.Optional[int] = None,
        total_amount_lt: typing.Optional[int] = None,
        total_amount_gte: typing.Optional[int] = None,
        total_amount_lte: typing.Optional[int] = None,
        amount: typing.Optional[int] = None,
        amount_gt: typing.Optional[int] = None,
        amount_lt: typing.Optional[int] = None,
        amount_gte: typing.Optional[int] = None,
        amount_lte: typing.Optional[int] = None,
        currency: typing.Optional[CurrencyEnum] = None,
        counterpart_name: typing.Optional[str] = None,
        counterpart_name_contains: typing.Optional[str] = None,
        counterpart_name_icontains: typing.Optional[str] = None,
        search_text: typing.Optional[str] = None,
        due_date: typing.Optional[str] = None,
        due_date_gt: typing.Optional[str] = None,
        due_date_lt: typing.Optional[str] = None,
        due_date_gte: typing.Optional[str] = None,
        due_date_lte: typing.Optional[str] = None,
        document_id: typing.Optional[str] = None,
        document_id_contains: typing.Optional[str] = None,
        document_id_icontains: typing.Optional[str] = None,
        was_created_by_user_id: typing.Optional[str] = None,
        counterpart_id: typing.Optional[str] = None,
        source_of_payable_data: typing.Optional[SourceOfPayableDataEnum] = None,
        ocr_status: typing.Optional[OcrStatusEnum] = None,
        line_item_id: typing.Optional[str] = None,
        purchase_order_id: typing.Optional[str] = None,
        project_id: typing.Optional[str] = None,
        tag_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PayableAnalyticsResponse:
        """
        Retrieve aggregated statistics for payables with different breakdowns.

        Parameters
        ----------
        metric : PayableMetricEnum

        aggregation_function : AggregationFunctionEnum

        dimension : typing.Optional[PayableDimensionEnum]

        date_dimension_breakdown : typing.Optional[DateDimensionBreakdownEnum]

        created_at_gt : typing.Optional[dt.datetime]
            Return only payables created in Monite after the specified date and time. The value must be in the ISO 8601 format YYYY-MM-DDThh:mm[:ss[.ffffff]][Z|±hh:mm].

        created_at_lt : typing.Optional[dt.datetime]
            Return only payables created in Monite before the specified date and time.

        created_at_gte : typing.Optional[dt.datetime]
            Return only payables created in Monite on or after the specified date and time.

        created_at_lte : typing.Optional[dt.datetime]
            Return only payables created in Monite before or on the specified date and time.

        status : typing.Optional[PayableStateEnum]
            Return only payables that have the specified [status](https://docs.monite.com/accounts-payable/payables/index).

            To query multiple statuses at once, use the `status__in` parameter instead.

        status_in : typing.Optional[typing.Union[PayableStateEnum, typing.Sequence[PayableStateEnum]]]
            Return only payables that have the specified [statuses](https://docs.monite.com/accounts-payable/payables/index).

            To specify multiple statuses, repeat this parameter for each value: `status__in=draft&status__in=new`

        id_in : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only payables with specified IDs. Valid but nonexistent IDs do not raise errors but produce no results.

            To specify multiple IDs, repeat this parameter for each value: `id__in=<id1>&id__in=<id2>`

        total_amount : typing.Optional[int]
            Return only payables with the exact specified total amount. The amount must be specified in the minor units of currency. For example, $12.5 is represented as 1250.

        total_amount_gt : typing.Optional[int]
            Return only payables whose total amount (in minor units) exceeds the specified value.

        total_amount_lt : typing.Optional[int]
            Return only payables whose total amount (in minor units) is less than the specified value.

        total_amount_gte : typing.Optional[int]
            Return only payables whose total amount (in minor units) is greater than or equal to the specified value.

        total_amount_lte : typing.Optional[int]
            Return only payables whose total amount (in minor units) is less than or equal to the specified value.

        amount : typing.Optional[int]
            Return only payables with the specified amount.

        amount_gt : typing.Optional[int]
            Return only payables whose amount (in minor units) exceeds the specified value.

        amount_lt : typing.Optional[int]
            Return only payables whose amount (in minor units) is less than the specified value.

        amount_gte : typing.Optional[int]
            Return only payables whose amount (in minor units) is greater than or equal to the specified value.

        amount_lte : typing.Optional[int]
            Return only payables whose amount (in minor units) is less than or equal to the specified value.

        currency : typing.Optional[CurrencyEnum]
            Return only payables that use the specified currency.

        counterpart_name : typing.Optional[str]
            Return only payables received from counterparts with the specified name (exact match, case-sensitive).

            For counterparts of `type = individual`, the full name is formatted as `first_name last_name`.

        counterpart_name_contains : typing.Optional[str]
            Return only payables received from counterparts whose name contains the specified string (case-sensitive).

        counterpart_name_icontains : typing.Optional[str]
            Return only payables received from counterparts whose name contains the specified string (case-insensitive).

        search_text : typing.Optional[str]
            Apply the `icontains` condition to search for the specified text in the `document_id` and `counterpart_name` fields in the payables.

        due_date : typing.Optional[str]
            Return payables that are due on the specified date (YYYY-MM-DD)

        due_date_gt : typing.Optional[str]
            Return payables that are due after the specified date (exclusive, YYYY-MM-DD).

        due_date_lt : typing.Optional[str]
            Return payables that are due before the specified date (exclusive, YYYY-MM-DD).

        due_date_gte : typing.Optional[str]
            Return payables that are due on or after the specified date (YYYY-MM-DD).

        due_date_lte : typing.Optional[str]
            Return payables that are due before or on the specified date (YYYY-MM-DD).

        document_id : typing.Optional[str]
            Return a payable with the exact specified document number (case-sensitive).

            The `document_id` is the user-facing document number such as INV-00042, not to be confused with Monite resource IDs (`id`).

        document_id_contains : typing.Optional[str]
            Return only payables whose document number (`document_id`) contains the specified string (case-sensitive).

        document_id_icontains : typing.Optional[str]
            Return only payables whose document number (`document_id`) contains the specified string (case-insensitive).

        was_created_by_user_id : typing.Optional[str]
            Return only payables created in Monite by the entity user with the specified ID.

        counterpart_id : typing.Optional[str]
            Return only payables received from the counterpart with the specified ID.

            Counterparts that have been deleted but have associated payables will still return results here because the payables contain a frozen copy of the counterpart data.

            If the specified counterpart ID does not exist and never existed, no results are returned.

        source_of_payable_data : typing.Optional[SourceOfPayableDataEnum]
            Return only payables coming from the specified source.

        ocr_status : typing.Optional[OcrStatusEnum]
            Return only payables with specific OCR statuses.

        line_item_id : typing.Optional[str]
            Search for a payable by the identifier of the line item associated with it.

        purchase_order_id : typing.Optional[str]
            Search for a payable by the identifier of the purchase order associated with it.

        project_id : typing.Optional[str]
            Return only payables assigned to the project with the specified ID.

            Valid but nonexistent project IDs do not raise errors but return no results.

        tag_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only payables whose `tags` include at least one of the tags with the specified IDs. Valid but nonexistent tag IDs do not raise errors but produce no results.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PayableAnalyticsResponse
            Successful Response

        Examples
        --------
        from monite import Monite

        client = Monite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )
        client.analytics.get_analytics_payables(
            metric="id",
            aggregation_function="count",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "analytics/payables",
            method="GET",
            params={
                "dimension": dimension,
                "metric": metric,
                "aggregation_function": aggregation_function,
                "date_dimension_breakdown": date_dimension_breakdown,
                "created_at__gt": serialize_datetime(created_at_gt) if created_at_gt is not None else None,
                "created_at__lt": serialize_datetime(created_at_lt) if created_at_lt is not None else None,
                "created_at__gte": serialize_datetime(created_at_gte) if created_at_gte is not None else None,
                "created_at__lte": serialize_datetime(created_at_lte) if created_at_lte is not None else None,
                "status": status,
                "status__in": status_in,
                "id__in": id_in,
                "total_amount": total_amount,
                "total_amount__gt": total_amount_gt,
                "total_amount__lt": total_amount_lt,
                "total_amount__gte": total_amount_gte,
                "total_amount__lte": total_amount_lte,
                "amount": amount,
                "amount__gt": amount_gt,
                "amount__lt": amount_lt,
                "amount__gte": amount_gte,
                "amount__lte": amount_lte,
                "currency": currency,
                "counterpart_name": counterpart_name,
                "counterpart_name__contains": counterpart_name_contains,
                "counterpart_name__icontains": counterpart_name_icontains,
                "search_text": search_text,
                "due_date": due_date,
                "due_date__gt": due_date_gt,
                "due_date__lt": due_date_lt,
                "due_date__gte": due_date_gte,
                "due_date__lte": due_date_lte,
                "document_id": document_id,
                "document_id__contains": document_id_contains,
                "document_id__icontains": document_id_icontains,
                "was_created_by_user_id": was_created_by_user_id,
                "counterpart_id": counterpart_id,
                "source_of_payable_data": source_of_payable_data,
                "ocr_status": ocr_status,
                "line_item_id": line_item_id,
                "purchase_order_id": purchase_order_id,
                "project_id": project_id,
                "tag_ids": tag_ids,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PayableAnalyticsResponse,
                    parse_obj_as(
                        type_=PayableAnalyticsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncAnalyticsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_analytics_credit_notes(
        self,
        *,
        metric: CreditNoteMetricEnum,
        aggregation_function: AggregationFunctionEnum,
        dimension: typing.Optional[CreditNoteDimensionEnum] = None,
        date_dimension_breakdown: typing.Optional[DateDimensionBreakdownEnum] = None,
        created_at_gt: typing.Optional[dt.datetime] = None,
        created_at_lt: typing.Optional[dt.datetime] = None,
        created_at_gte: typing.Optional[dt.datetime] = None,
        created_at_lte: typing.Optional[dt.datetime] = None,
        issued_at: typing.Optional[str] = None,
        issued_at_gt: typing.Optional[str] = None,
        issued_at_lt: typing.Optional[str] = None,
        issued_at_gte: typing.Optional[str] = None,
        issued_at_lte: typing.Optional[str] = None,
        document_id: typing.Optional[str] = None,
        document_id_iexact: typing.Optional[str] = None,
        document_id_contains: typing.Optional[str] = None,
        document_id_icontains: typing.Optional[str] = None,
        total_amount_gt: typing.Optional[int] = None,
        total_amount_lt: typing.Optional[int] = None,
        total_amount_gte: typing.Optional[int] = None,
        total_amount_lte: typing.Optional[int] = None,
        subtotal_gt: typing.Optional[int] = None,
        subtotal_lt: typing.Optional[int] = None,
        subtotal_gte: typing.Optional[int] = None,
        subtotal_lte: typing.Optional[int] = None,
        based_on: typing.Optional[str] = None,
        counterpart_id: typing.Optional[str] = None,
        created_by_entity_user_id: typing.Optional[str] = None,
        status: typing.Optional[CreditNoteStateEnum] = None,
        status_in: typing.Optional[typing.Union[CreditNoteStateEnum, typing.Sequence[CreditNoteStateEnum]]] = None,
        status_not_in: typing.Optional[typing.Union[CreditNoteStateEnum, typing.Sequence[CreditNoteStateEnum]]] = None,
        currency: typing.Optional[CurrencyEnum] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PayableAnalyticsResponse:
        """
        Retrieve aggregated statistics for payables with different breakdowns.

        Parameters
        ----------
        metric : CreditNoteMetricEnum

        aggregation_function : AggregationFunctionEnum

        dimension : typing.Optional[CreditNoteDimensionEnum]

        date_dimension_breakdown : typing.Optional[DateDimensionBreakdownEnum]

        created_at_gt : typing.Optional[dt.datetime]

        created_at_lt : typing.Optional[dt.datetime]

        created_at_gte : typing.Optional[dt.datetime]

        created_at_lte : typing.Optional[dt.datetime]

        issued_at : typing.Optional[str]

        issued_at_gt : typing.Optional[str]

        issued_at_lt : typing.Optional[str]

        issued_at_gte : typing.Optional[str]

        issued_at_lte : typing.Optional[str]

        document_id : typing.Optional[str]

        document_id_iexact : typing.Optional[str]

        document_id_contains : typing.Optional[str]

        document_id_icontains : typing.Optional[str]

        total_amount_gt : typing.Optional[int]

        total_amount_lt : typing.Optional[int]

        total_amount_gte : typing.Optional[int]

        total_amount_lte : typing.Optional[int]

        subtotal_gt : typing.Optional[int]

        subtotal_lt : typing.Optional[int]

        subtotal_gte : typing.Optional[int]

        subtotal_lte : typing.Optional[int]

        based_on : typing.Optional[str]

        counterpart_id : typing.Optional[str]

        created_by_entity_user_id : typing.Optional[str]

        status : typing.Optional[CreditNoteStateEnum]

        status_in : typing.Optional[typing.Union[CreditNoteStateEnum, typing.Sequence[CreditNoteStateEnum]]]

        status_not_in : typing.Optional[typing.Union[CreditNoteStateEnum, typing.Sequence[CreditNoteStateEnum]]]

        currency : typing.Optional[CurrencyEnum]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PayableAnalyticsResponse
            Successful Response

        Examples
        --------
        import asyncio

        from monite import AsyncMonite

        client = AsyncMonite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.analytics.get_analytics_credit_notes(
                metric="id",
                aggregation_function="count",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "analytics/credit_notes",
            method="GET",
            params={
                "dimension": dimension,
                "metric": metric,
                "aggregation_function": aggregation_function,
                "date_dimension_breakdown": date_dimension_breakdown,
                "created_at__gt": serialize_datetime(created_at_gt) if created_at_gt is not None else None,
                "created_at__lt": serialize_datetime(created_at_lt) if created_at_lt is not None else None,
                "created_at__gte": serialize_datetime(created_at_gte) if created_at_gte is not None else None,
                "created_at__lte": serialize_datetime(created_at_lte) if created_at_lte is not None else None,
                "issued_at": issued_at,
                "issued_at__gt": issued_at_gt,
                "issued_at__lt": issued_at_lt,
                "issued_at__gte": issued_at_gte,
                "issued_at__lte": issued_at_lte,
                "document_id": document_id,
                "document_id__iexact": document_id_iexact,
                "document_id__contains": document_id_contains,
                "document_id__icontains": document_id_icontains,
                "total_amount__gt": total_amount_gt,
                "total_amount__lt": total_amount_lt,
                "total_amount__gte": total_amount_gte,
                "total_amount__lte": total_amount_lte,
                "subtotal__gt": subtotal_gt,
                "subtotal__lt": subtotal_lt,
                "subtotal__gte": subtotal_gte,
                "subtotal__lte": subtotal_lte,
                "based_on": based_on,
                "counterpart_id": counterpart_id,
                "created_by_entity_user_id": created_by_entity_user_id,
                "status": status,
                "status__in": status_in,
                "status__not_in": status_not_in,
                "currency": currency,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PayableAnalyticsResponse,
                    parse_obj_as(
                        type_=PayableAnalyticsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_analytics_payables(
        self,
        *,
        metric: PayableMetricEnum,
        aggregation_function: AggregationFunctionEnum,
        dimension: typing.Optional[PayableDimensionEnum] = None,
        date_dimension_breakdown: typing.Optional[DateDimensionBreakdownEnum] = None,
        created_at_gt: typing.Optional[dt.datetime] = None,
        created_at_lt: typing.Optional[dt.datetime] = None,
        created_at_gte: typing.Optional[dt.datetime] = None,
        created_at_lte: typing.Optional[dt.datetime] = None,
        status: typing.Optional[PayableStateEnum] = None,
        status_in: typing.Optional[typing.Union[PayableStateEnum, typing.Sequence[PayableStateEnum]]] = None,
        id_in: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        total_amount: typing.Optional[int] = None,
        total_amount_gt: typing.Optional[int] = None,
        total_amount_lt: typing.Optional[int] = None,
        total_amount_gte: typing.Optional[int] = None,
        total_amount_lte: typing.Optional[int] = None,
        amount: typing.Optional[int] = None,
        amount_gt: typing.Optional[int] = None,
        amount_lt: typing.Optional[int] = None,
        amount_gte: typing.Optional[int] = None,
        amount_lte: typing.Optional[int] = None,
        currency: typing.Optional[CurrencyEnum] = None,
        counterpart_name: typing.Optional[str] = None,
        counterpart_name_contains: typing.Optional[str] = None,
        counterpart_name_icontains: typing.Optional[str] = None,
        search_text: typing.Optional[str] = None,
        due_date: typing.Optional[str] = None,
        due_date_gt: typing.Optional[str] = None,
        due_date_lt: typing.Optional[str] = None,
        due_date_gte: typing.Optional[str] = None,
        due_date_lte: typing.Optional[str] = None,
        document_id: typing.Optional[str] = None,
        document_id_contains: typing.Optional[str] = None,
        document_id_icontains: typing.Optional[str] = None,
        was_created_by_user_id: typing.Optional[str] = None,
        counterpart_id: typing.Optional[str] = None,
        source_of_payable_data: typing.Optional[SourceOfPayableDataEnum] = None,
        ocr_status: typing.Optional[OcrStatusEnum] = None,
        line_item_id: typing.Optional[str] = None,
        purchase_order_id: typing.Optional[str] = None,
        project_id: typing.Optional[str] = None,
        tag_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PayableAnalyticsResponse:
        """
        Retrieve aggregated statistics for payables with different breakdowns.

        Parameters
        ----------
        metric : PayableMetricEnum

        aggregation_function : AggregationFunctionEnum

        dimension : typing.Optional[PayableDimensionEnum]

        date_dimension_breakdown : typing.Optional[DateDimensionBreakdownEnum]

        created_at_gt : typing.Optional[dt.datetime]
            Return only payables created in Monite after the specified date and time. The value must be in the ISO 8601 format YYYY-MM-DDThh:mm[:ss[.ffffff]][Z|±hh:mm].

        created_at_lt : typing.Optional[dt.datetime]
            Return only payables created in Monite before the specified date and time.

        created_at_gte : typing.Optional[dt.datetime]
            Return only payables created in Monite on or after the specified date and time.

        created_at_lte : typing.Optional[dt.datetime]
            Return only payables created in Monite before or on the specified date and time.

        status : typing.Optional[PayableStateEnum]
            Return only payables that have the specified [status](https://docs.monite.com/accounts-payable/payables/index).

            To query multiple statuses at once, use the `status__in` parameter instead.

        status_in : typing.Optional[typing.Union[PayableStateEnum, typing.Sequence[PayableStateEnum]]]
            Return only payables that have the specified [statuses](https://docs.monite.com/accounts-payable/payables/index).

            To specify multiple statuses, repeat this parameter for each value: `status__in=draft&status__in=new`

        id_in : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only payables with specified IDs. Valid but nonexistent IDs do not raise errors but produce no results.

            To specify multiple IDs, repeat this parameter for each value: `id__in=<id1>&id__in=<id2>`

        total_amount : typing.Optional[int]
            Return only payables with the exact specified total amount. The amount must be specified in the minor units of currency. For example, $12.5 is represented as 1250.

        total_amount_gt : typing.Optional[int]
            Return only payables whose total amount (in minor units) exceeds the specified value.

        total_amount_lt : typing.Optional[int]
            Return only payables whose total amount (in minor units) is less than the specified value.

        total_amount_gte : typing.Optional[int]
            Return only payables whose total amount (in minor units) is greater than or equal to the specified value.

        total_amount_lte : typing.Optional[int]
            Return only payables whose total amount (in minor units) is less than or equal to the specified value.

        amount : typing.Optional[int]
            Return only payables with the specified amount.

        amount_gt : typing.Optional[int]
            Return only payables whose amount (in minor units) exceeds the specified value.

        amount_lt : typing.Optional[int]
            Return only payables whose amount (in minor units) is less than the specified value.

        amount_gte : typing.Optional[int]
            Return only payables whose amount (in minor units) is greater than or equal to the specified value.

        amount_lte : typing.Optional[int]
            Return only payables whose amount (in minor units) is less than or equal to the specified value.

        currency : typing.Optional[CurrencyEnum]
            Return only payables that use the specified currency.

        counterpart_name : typing.Optional[str]
            Return only payables received from counterparts with the specified name (exact match, case-sensitive).

            For counterparts of `type = individual`, the full name is formatted as `first_name last_name`.

        counterpart_name_contains : typing.Optional[str]
            Return only payables received from counterparts whose name contains the specified string (case-sensitive).

        counterpart_name_icontains : typing.Optional[str]
            Return only payables received from counterparts whose name contains the specified string (case-insensitive).

        search_text : typing.Optional[str]
            Apply the `icontains` condition to search for the specified text in the `document_id` and `counterpart_name` fields in the payables.

        due_date : typing.Optional[str]
            Return payables that are due on the specified date (YYYY-MM-DD)

        due_date_gt : typing.Optional[str]
            Return payables that are due after the specified date (exclusive, YYYY-MM-DD).

        due_date_lt : typing.Optional[str]
            Return payables that are due before the specified date (exclusive, YYYY-MM-DD).

        due_date_gte : typing.Optional[str]
            Return payables that are due on or after the specified date (YYYY-MM-DD).

        due_date_lte : typing.Optional[str]
            Return payables that are due before or on the specified date (YYYY-MM-DD).

        document_id : typing.Optional[str]
            Return a payable with the exact specified document number (case-sensitive).

            The `document_id` is the user-facing document number such as INV-00042, not to be confused with Monite resource IDs (`id`).

        document_id_contains : typing.Optional[str]
            Return only payables whose document number (`document_id`) contains the specified string (case-sensitive).

        document_id_icontains : typing.Optional[str]
            Return only payables whose document number (`document_id`) contains the specified string (case-insensitive).

        was_created_by_user_id : typing.Optional[str]
            Return only payables created in Monite by the entity user with the specified ID.

        counterpart_id : typing.Optional[str]
            Return only payables received from the counterpart with the specified ID.

            Counterparts that have been deleted but have associated payables will still return results here because the payables contain a frozen copy of the counterpart data.

            If the specified counterpart ID does not exist and never existed, no results are returned.

        source_of_payable_data : typing.Optional[SourceOfPayableDataEnum]
            Return only payables coming from the specified source.

        ocr_status : typing.Optional[OcrStatusEnum]
            Return only payables with specific OCR statuses.

        line_item_id : typing.Optional[str]
            Search for a payable by the identifier of the line item associated with it.

        purchase_order_id : typing.Optional[str]
            Search for a payable by the identifier of the purchase order associated with it.

        project_id : typing.Optional[str]
            Return only payables assigned to the project with the specified ID.

            Valid but nonexistent project IDs do not raise errors but return no results.

        tag_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Return only payables whose `tags` include at least one of the tags with the specified IDs. Valid but nonexistent tag IDs do not raise errors but produce no results.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PayableAnalyticsResponse
            Successful Response

        Examples
        --------
        import asyncio

        from monite import AsyncMonite

        client = AsyncMonite(
            monite_version="YOUR_MONITE_VERSION",
            monite_entity_id="YOUR_MONITE_ENTITY_ID",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.analytics.get_analytics_payables(
                metric="id",
                aggregation_function="count",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "analytics/payables",
            method="GET",
            params={
                "dimension": dimension,
                "metric": metric,
                "aggregation_function": aggregation_function,
                "date_dimension_breakdown": date_dimension_breakdown,
                "created_at__gt": serialize_datetime(created_at_gt) if created_at_gt is not None else None,
                "created_at__lt": serialize_datetime(created_at_lt) if created_at_lt is not None else None,
                "created_at__gte": serialize_datetime(created_at_gte) if created_at_gte is not None else None,
                "created_at__lte": serialize_datetime(created_at_lte) if created_at_lte is not None else None,
                "status": status,
                "status__in": status_in,
                "id__in": id_in,
                "total_amount": total_amount,
                "total_amount__gt": total_amount_gt,
                "total_amount__lt": total_amount_lt,
                "total_amount__gte": total_amount_gte,
                "total_amount__lte": total_amount_lte,
                "amount": amount,
                "amount__gt": amount_gt,
                "amount__lt": amount_lt,
                "amount__gte": amount_gte,
                "amount__lte": amount_lte,
                "currency": currency,
                "counterpart_name": counterpart_name,
                "counterpart_name__contains": counterpart_name_contains,
                "counterpart_name__icontains": counterpart_name_icontains,
                "search_text": search_text,
                "due_date": due_date,
                "due_date__gt": due_date_gt,
                "due_date__lt": due_date_lt,
                "due_date__gte": due_date_gte,
                "due_date__lte": due_date_lte,
                "document_id": document_id,
                "document_id__contains": document_id_contains,
                "document_id__icontains": document_id_icontains,
                "was_created_by_user_id": was_created_by_user_id,
                "counterpart_id": counterpart_id,
                "source_of_payable_data": source_of_payable_data,
                "ocr_status": ocr_status,
                "line_item_id": line_item_id,
                "purchase_order_id": purchase_order_id,
                "project_id": project_id,
                "tag_ids": tag_ids,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PayableAnalyticsResponse,
                    parse_obj_as(
                        type_=PayableAnalyticsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
